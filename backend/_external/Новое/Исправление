принял. по логам у тебя сейчас три конкретные проблемы, из-за которых всё «висит»:

CEF не поедет на твоём Python 3.13.7. pywebview/cefpython3 просто не поддерживают 3.13 → любой заход на gui='cef' = холостой прогон и потеря времени.

Текущая связка Edge WebView2 + pywebview (новой ветки) дергает современные интерфейсы ICoreWebView2_* (вплоть до _20), а у тебя рантайм WebView2 на машине/в инсталляции не той версии → куча E_NOINTERFACE и «CoreWebView2 members… UI thread».

Хак с JavaScript-«чисткой» window.native ломает ивент-петлю и/или мосты (и «Аккаунты» висят), потому что код PyWebView/WinForms тоже юзает window.native. Эту чистку надо убрать, иначе местами UI просто замирает.

Ниже — чёткий фикс-план и точные правки файлов. Делай ровно так — запуск станет стабильным и быстрым на твоём Python 3.13, без отката на 3.11 и без CEF.

P0. Стабилизируем движок окна на Python 3.13 (только Edge)
0) Обнови WebView2 до последнего Evergreen

На каждой машине (в т.ч. dev), где будем запускать:

скачай официальный Evergreen Runtime (x64):
https://go.microsoft.com/fwlink/p/?LinkId=2124703
установи молча (или ручной установкой). Это один раз.
Это погасит все ICoreWebView2_* «Interface not supported» в твоём логе.

1) Убери попытку CEF и любые «очистки окна»

Никакого gui='cef' на 3.13 (в логах: Python version not supported: 3.13.7).

Убери любой JS, который трогает window.native. Он не нужен и рушит PyWebView/WinForms.

Файл: launcher.py — минимальный и безопасный старт (Edge только):

import os, threading, time, urllib.request, webview
from uvicorn import Config, Server

HOST, PORT = "127.0.0.1", 8765
UI_URL = f"http://{HOST}:{PORT}/"

def run_backend():
    Server(Config("backend.main:app", host=HOST, port=PORT, log_level="info", reload=False)).run()

def wait_health(url, timeout=20):
    t0 = time.time()
    while time.time() - t0 < timeout:
        try:
            with urllib.request.urlopen(url, timeout=1) as r:
                if r.status == 200:
                    return True
        except Exception:
            time.sleep(0.15)
    return False

if __name__ == "__main__":
    # 1) Только Edge WebView2. Не трогаем window.native. Не пробуем CEF/MSHTML.
    os.environ["PYWEBVIEW_GUI"] = "edgechromium"
    # (опционально) просим стабильный канал RUNTIME
    os.environ["WEBVIEW2_RELEASE_CHANNEL_PREFERENCE"] = "1"  # Stable

    # 2) Стартуем бэкенд и ждем health
    threading.Thread(target=run_backend, daemon=True).start()
    ok = wait_health(f"http://{HOST}:{PORT}/api/health", 20)

    # 3) Окно без дополнительных «трюков»
    url = UI_URL if ok else f"http://{HOST}:{PORT}/splash"
    webview.create_window("KeySet", url, width=1280, height=800, min_size=(1024, 700))
    webview.start(debug=False)  # по PYWEBVIEW_GUI возьмется edgechromium


Это убирает:
• холостой прогон CEF,
• любые манипуляции с window.native,
• вызовы evaluate_js не по UI-треду.
И оставляет ровно то, что стабильно работает на 3.13 при свежем Evergreen Runtime.

P1. Ускоряем старт (окно ≤1 c, UI ≤2–3 c)
2) Бэкенд: сжатие + кэш статики + никаких тяжёлых действий на старте

Файл: backend/main.py (суть — включи gzip, immutable-кэш и вынеси миграции из синхронного старта):

from fastapi import FastAPI
from fastapi.responses import HTMLResponse, FileResponse
from starlette.staticfiles import StaticFiles
from starlette.middleware.gzip import GZipMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from pathlib import Path
import threading

app = FastAPI()
app.add_middleware(GZipMiddleware, minimum_size=1024)

DIST = Path(__file__).resolve().parent.parent / "frontend" / "dist"

class AssetCacheMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        resp = await call_next(request)
        p = request.url.path
        if p.startswith("/assets/") or p.endswith(".css"):
            resp.headers["Cache-Control"] = "public, max-age=31536000, immutable"
        return resp

app.add_middleware(AssetCacheMiddleware)

@app.get("/api/health")
def health():
    return {"ok": True}

@app.get("/splash", response_class=HTMLResponse)
def splash():
    return """<!doctype html><meta charset="utf-8">
<style>html,body{height:100%;margin:0;display:grid;place-items:center;background:#0b0e14;color:#e5e9f0;font:14px system-ui}
.s{width:28px;height:28px;border:3px solid #3b4252;border-top-color:transparent;border-radius:50%;animation:sp .8s linear infinite}
@keyframes sp{to{transform:rotate(360deg)}}</style>
<div><div class="s"></div><div style="margin-top:8px">Запуск KeySet…</div></div>
<script>(async()=>{let ok=false;for(let i=0;i<100;i++){try{ok=(await fetch('/api/health',{cache:'no-store'})).ok}catch{} if(ok)break;await new Promise(r=>setTimeout(r,120))}location.href='/'})()</script>"""

if DIST.exists():
    app.mount("/assets", StaticFiles(directory=DIST / "assets"), name="assets")
    @app.get("/{full_path:path}")
    def spa(full_path: str):
        return FileResponse(DIST / "index.html")

@app.on_event("startup")
def _migrate_async():
    def job():
        try:
            from keyset.core.migrations import migrate_if_needed
            migrate_if_needed()
        except Exception as e:
            print("migrate warn:", e)
    threading.Thread(target=job, daemon=True).start()

3) Фронт уже собран в один бандл — оставь как есть

В vite.config.ts не возвращай manualChunks.

sourcemap:false, cssCodeSplit:false → ок.

(можно добавить minify:'terser', drop_console:true — даст +10–15% к разбору JS на холодном старте; не обязательно).

P2. «Аккаунты/Данные» не грузятся — добиваем цепочку

Судя по твоему логу, бэкенд отвечает 200 на /api/accounts, а UI виснет из-за флуда от WebView2. После снятия «очистки window.native» и приведения Edge в порядок:

Проверь руками:

curl http://127.0.0.1:8765/api/health
curl http://127.0.0.1:8765/api/accounts
curl "http://127.0.0.1:8765/api/data/phrases?limit=5"


— все три должны отдавать 200 и валидные ответы.

Если вкладка «Данные» пуста — проверь, что POST /api/wordstat/collect делает upsert в freq_results (это мы уже чинили). После завершения сбора строки обязаны появляться в таблице без перезапуска.

Почему это решит именно твой кейс

Python 3.13 + CEF → исключены (ты видишь ошибку об неподдерживаемой версии). Мы не тратим на это ни миллисекунды.

Edge WebView2 → при свежем Evergreen рантайме pywebview не дёргает несуществующие ICoreWebView2_* интерфейсы, и нет твоих «Empty… recursion depth exceeded».

window.native больше не трогаем — никаких побочных зависаний UI. Мост pywebview.api жив, «Аккаунты» и «Данные» грузятся.

Кэш/сжатие/без миграций на горячем пути → окно за <1 с, UI за 1–3 с, повторный старт <1 с.

Что конкретно сделать сейчас (чек-лист)

Установи Edge WebView2 Evergreen Runtime (ссылка выше).

Заменить launcher.py на версию из P0 (только Edge, без CEF и без JS-хаков).

Обновить backend/main.py как в P1 (gzip + immutable cache + миграции в фоне).

Собрать фронт (один бандл) и запустить:

pnpm run build
python .\backend\launcher.py


Проверить /api/health, /api/accounts, «Данные», запустить частотку — строки появились.

Если после этого где-то останутся микро-затыки — я дам точный дифф под vite.config.ts (терсер-минификация) и проверю твои API-ручки «Данные/Экспорт», но сначала важно снять фриз именно на старте окна, и этот набор правок делает это безотказно на твоём стеке и твоей версии Python.