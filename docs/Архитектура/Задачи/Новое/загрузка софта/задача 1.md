он мне уже сделал сборку, мне нужно чтобы у меня было сразу в софте, чтобы я не парился потом с подключением. У меня не подгружаются данные и аккаунты и чето там дофига еще похоже, но приложение запускается - вот скрин. Обязательно PySide6 Qt WebEngine если он уже собрал софт, может обойдемся без всякой доп дичи которая усложнаяет логику и ломает все - он так на разных ос не запустится?

Принял. Без лишней теории — чинить «Failed to fetch» и пустые вкладки так, чтобы .exe «как софт» стартовал за секунду и всё связалось.

 пиши по русски, ну у нас же файлы находятся в этой папке C:\AI\yandex\KeySet-MVP, делай здесь сборку без всяких 
переделок на другие директории. Просто здесь у меня старый софт на питоне со всеми рабочими парсерами 
C:\AI\yandex\KeySet-MVP\keyset, мне нужно чтобы ты весь рабочий софт делал здесь C:\AI\yandex\KeySet-MVP. Не обязательно    
 сразу делать сборку - сборка это подготовка всего рабочего инструментала, потом уже будем делать ексе файлы и прочее,      
когда софт будет полностью рабочим. 
Софт должен находиться в 1 месте, ты его уже      
  сделал частично, он уже запускается от сюда C:\AI\yandex\KeySet-MVP\dist. Сейчас твоя задача собрать все вместе и все     
  подключить. Вкладка аккаунты и данные не грузятся, их нужно подключить и связать функционал чтобы все работало, это тоже  
  все у нас есть, почти все готовые модули, данные, профили и.т.д - твоя задача это все связать , не удаляя и не ломая то    
  что уже работает, ненадо время тратить на пересборку рабочего софта, постарайся тратить меньше токенов. 




В твоей сборке UI открывается, но фронт не видит API и БД. Типичные причины (и они как раз дают «Failed to fetch»):

UI открыт не с того же origin, что API (другой порт/URL) → /api/* уходит в никуда.

SPA не смонтирована через FastAPI (нет раздачи frontend/dist из бэка) → UI/API живут на разных источниках.

База не вынесена наружу и/или не скопирована на первый запуск → при доступе к таблицам валится 500, фронт показывает «Failed to fetch».

В фронте жёстко прописан baseURL (например, http://127.0.0.1:5173/8765) → при другом порте сразу сетевые ошибки.

Ни PySide/CEF/WebView2 тут не нужны. Лечим связку.

План фикса (минимум правок, быстро)
Шаг 1 — Один порт и один origin

Фиксируем порт, чтобы фронт и бэк всегда были вместе:

в лаунчере запускаем Uvicorn на 127.0.0.1:8765;

окно Edge открываем строго на http://127.0.0.1:8765 (а не на 5173/dev и не на случайный порт).

# launcher.py (кусок)
import subprocess, sys, time, os

PORT = "8765"

# поднимаем бекенд как модуль uvicorn с нашим приложением
backend = subprocess.Popen([
    sys.executable, "-m", "uvicorn",
    "backend.main:app",
    "--host", "127.0.0.1",
    "--port", PORT,
    "--log-level", "info"
], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

# короткая пауза, можно заменить на health-check
time.sleep(1.5)

# открываем Edge в app-режиме на том же origin
subprocess.Popen([
    "msedge", f"--app=http://127.0.0.1:{PORT}",
    r"--user-data-dir=%TEMP%\KeySet",
    "--disable-extensions", "--disable-plugins"
])

Шаг 2 — Раздаём React как SPA из FastAPI

Чтобы всегда был один origin, монтируем frontend/dist в корень:

# backend/main.py (важно расположить после include_router)
import os, sys
from pathlib import Path
from fastapi.staticfiles import StaticFiles

def _dist_dir() -> str:
    # для обычного запуска и для PyInstaller (sys._MEIPASS)
    base = Path(getattr(sys, "_MEIPASS", Path(__file__).resolve().parents[2]))
    # если dist лежит рядом с backend/, поправь путь под свой проект
    dist = base / "frontend" / "dist"
    return str(dist)

app.mount("/", StaticFiles(directory=_dist_dir(), html=True), name="static")


Теперь UI и /api — один и тот же http://127.0.0.1:8765. Никаких CORS и «Failed to fetch» из-за другого порта.

Шаг 3 — Вынести БД наружу (чтобы не пересобирать .exe из-за базы)

При первом запуске копируем шаблон БД из ресурсов в %USERPROFILE%\.keyset\keyset.db и всегда работаем с этим файлом:

# keyset/core/db_path.py (новый маленький модуль)
import os, sys, shutil
from pathlib import Path

APP_DIR = Path(os.environ.get("KEYSET_HOME", Path.home() / ".keyset"))
APP_DIR.mkdir(parents=True, exist_ok=True)
DB_PATH = APP_DIR / "keyset.db"

def _bundled_db() -> Path:
    base = Path(getattr(sys, "_MEIPASS", Path(__file__).resolve().parents[2]))
    # поправь путь, где лежит шаблон БД в твоём проекте/спеке
    return base / "keyset" / "data" / "keyset.db"

if not DB_PATH.exists():
    src = _bundled_db()
    if src.exists():
        shutil.copy2(src, DB_PATH)

SQLALCHEMY_URL = f"sqlite:///{DB_PATH}"


И в инициализации движка:

# keyset/core/db.py
from .db_path import SQLALCHEMY_URL
engine = create_engine(SQLALCHEMY_URL, connect_args={"check_same_thread": False})


Так ты никогда не пересобираешь из-за содержимого БД: надо заменить БД — просто положи новый файл в %USERPROFILE%\.keyset\keyset.db.

Шаг 4 — Фронтенд: без хардкода baseURL

Проверь клиент API. Должно быть относительное:

// src/shared/api.ts (или где у тебя fetch/axios)
const api = axios.create({ baseURL: "/api" }); // не http://127.0.0.1:порт


Если где-то остался хардкод http://localhost:5173 или 8765 — убери. Тогда при любом способе запуска всё «прилипнет» к текущему origin.

Шаг 5 — PyInstaller: положить статику и шаблон БД

В .spec должны быть datas для frontend/dist и для шаблона БД/JSON:

a = Analysis(
    ['launcher.py'],
    datas=[
        ('frontend/dist', 'frontend/dist'),                 # React статика
        ('keyset/data/keyset.db', 'keyset/data'),           # шаблон БД
        ('keyset/data/regions_tree_full.json', 'keyset/data')
    ],
    hiddenimports=['uvicorn', 'fastapi', ...],
    ...
)

Быстрый самотест (3 шага)

Запусти KeySet.exe.

В адресной строке окна набери http://127.0.0.1:8765/api/health — должен вернуть 200 OK.

Открой http://127.0.0.1:8765/api/accounts — если пусто, придёт []; если ошибка — увидишь код/текст (значит ещё БД/модели).

Если health не отвечает — лаунчер не открыл тот же порт, чинить Шаг 1.
Если health ок, а /api/accounts 500 — смотри лог бэка (чаще всего БД не скопировалась/путь). После Шага 3 это уйдёт.

Ответы на твои вопросы (коротко)

Сборка ради БД? Нет, если БД вынесена наружу (как выше).

WebView2/подпись/PySide6? Убрали — и правильно. Для запуска/связки не нужны.

Кроссплатформенность? Сейчас целимся в Win и быстрый запуск. Под другие ОС — отдельно, но логика останется та же (один origin + SPA из FastAPI).

Хочешь — дам готовые патчи (диффы) под твои файлы backend/main.py, keyset/core/db.py, launcher.py и кусок spec, чтобы ты просто вставил и пересобрал. Это как раз 10–15 минут правок и сборка.

ок, делаем «портативный» KeySet: один каталог с .exe и всей нужной начинкой (БД, профили, парсер, регионы, Playwright-браузер), чтобы после сборки можно было почистить машину и запускать из одной папки.

ниже — готовый план + вставки кода/спека. бери и вставляй.

TL;DR

UI и API на одном origin: FastAPI раздаёт frontend/dist (SPA) и слушает 127.0.0.1:8765.

Одна папка runtime/ рядом с exe: тут лежат db/, profiles/, browsers/ (Chromium для Playwright), geo/, config/, logs/.

БД и прочее копируются на первый запуск из ресурсов exe в runtime/.

Playwright браузер кладём внутрь проекта (без внешних кэшей).

PyInstaller упаковывает всё; после сборки можно удалять venv, node_modules, глобальные кэши Playwright.

1) Целевая структура (после сборки)
KeySet/
├─ KeySet.exe
├─ runtime/
│  ├─ db/                  # рабочая БД (внешний файл)
│  │   └─ keyset.db
│  ├─ profiles/            # профили аккаунтов (user_data_dir)
│  ├─ browsers/            # ms-playwright Chromium (внутри проекта)
│  ├─ geo/
│  │   └─ regions_tree_full.json
│  ├─ config/
│  │   ├─ proxies.json
│  │   └─ .env
│  └─ logs/
└─ www/                    # собранный React (frontend/dist)


Внутрь exe также кладём «шаблоны» (dist, дефолтную БД, geo). На первом запуске — копируем в runtime/.

2) Централизованные пути (один модуль)

keyset/core/app_paths.py

from __future__ import annotations
import os, sys, shutil
from pathlib import Path

def _app_root() -> Path:
    # frozen exe -> рядом с exe, dev -> корень репо
    if getattr(sys, 'frozen', False):
        return Path(sys.executable).resolve().parent
    return Path(__file__).resolve().parents[3]  # подстрой при необходимости

APP_ROOT = _app_root()
RUNTIME = APP_ROOT / 'runtime'
WWW_DIR = APP_ROOT / 'www'   # куда копируем dist на сборке

# подпапки runtime
DB_DIR      = RUNTIME / 'db'
PROFILES    = RUNTIME / 'profiles'
BROWSERS    = RUNTIME / 'browsers'  # PLAYWRIGHT_BROWSERS_PATH
GEO_DIR     = RUNTIME / 'geo'
CONFIG_DIR  = RUNTIME / 'config'
LOGS_DIR    = RUNTIME / 'logs'

def ensure_runtime():
    for p in (DB_DIR, PROFILES, BROWSERS, GEO_DIR, CONFIG_DIR, LOGS_DIR):
        p.mkdir(parents=True, exist_ok=True)

def _bundle_dir() -> Path:
    # где лежат «шаблоны» внутри exe / при dev-сборке
    base = Path(getattr(sys, "_MEIPASS", APP_ROOT))
    return base

def bootstrap_files():
    """Копируем дефолтную БД/geo/конфиги из ресурсов в runtime при первом запуске"""
    ensure_runtime()
    # БД
    bundled_db = _bundle_dir() / 'keyset' / 'data' / 'keyset.db'
    target_db  = DB_DIR / 'keyset.db'
    if bundled_db.exists() and not target_db.exists():
        shutil.copy2(bundled_db, target_db)
    # GEO
    bundled_geo = _bundle_dir() / 'keyset' / 'data' / 'regions_tree_full.json'
    target_geo  = GEO_DIR / 'regions_tree_full.json'
    if bundled_geo.exists() and not target_geo.exists():
        shutil.copy2(bundled_geo, target_geo)
    # CONFIG (если нужны дефолты)
    bundled_proxies = _bundle_dir() / 'keyset' / 'data' / 'proxies.json'
    if bundled_proxies.exists() and not (CONFIG_DIR / 'proxies.json').exists():
        shutil.copy2(bundled_proxies, CONFIG_DIR / 'proxies.json')

def sqlite_url() -> str:
    return f"sqlite:///{(DB_DIR / 'keyset.db').as_posix()}"

3) Подключаем пути в БД и сервисах

keyset/core/db.py (фрагмент)

from sqlalchemy import create_engine
from .app_paths import bootstrap_files, sqlite_url

bootstrap_files()
engine = create_engine(sqlite_url(), connect_args={"check_same_thread": False})


Playwright/парсер: кладём профили и браузер внутрь runtime/:

import os
from keyset.core.app_paths import PROFILES, BROWSERS

# браузер внутри проекта
os.environ["PLAYWRIGHT_BROWSERS_PATH"] = str(BROWSERS)

# user_data_dir для аккаунтов
def profile_dir(account_id: int) -> str:
    p = PROFILES / f"acc_{account_id}"
    p.mkdir(parents=True, exist_ok=True)
    return str(p)


В вызове Playwright используй user_data_dir=profile_dir(acc.id).

4) FastAPI раздаёт SPA (один origin)

backend/main.py (фрагмент)

from fastapi.staticfiles import StaticFiles
from keyset.core.app_paths import WWW_DIR, bootstrap_files, ensure_runtime

ensure_runtime(); bootstrap_files()

# ...routers...
app.mount("/", StaticFiles(directory=str(WWW_DIR), html=True), name="static")


В сборке мы заранее копируем frontend/dist в www/. Тогда окно Edge открывается на http://127.0.0.1:8765/, и все /api/* — тот же origin (никаких CORS «Failed to fetch»).

5) Лаунчер (Edge в app-режиме, один порт)

launcher.py (минимум)

import subprocess, sys, time, os
from keyset.core.app_paths import APP_ROOT

PORT = "8765"

backend = subprocess.Popen([
    sys.executable, "-m", "uvicorn", "backend.main:app",
    "--host", "127.0.0.1", "--port", PORT, "--log-level", "warning"
], cwd=str(APP_ROOT), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

time.sleep(1.5)  # можно заменить на health-check

subprocess.Popen([
    "msedge", f"--app=http://127.0.0.1:{PORT}/",
    rf"--user-data-dir={APP_ROOT}\runtime\edge_profile",
    "--disable-extensions", "--disable-plugins"
], cwd=str(APP_ROOT))

6) Готовим браузер Playwright внутрь проекта

Перед сборкой единожды поставь Chromium в runtime/browsers:

REM из корня проекта
set PLAYWRIGHT_BROWSERS_PATH=runtime\browsers
py -m pip install playwright
py -m playwright install chromium


В результате папка runtime\browsers\ содержит нужные бинарники → PyInstaller их заберёт как datas.

7) PyInstaller spec (один файл, всё внутри)

build/KeySet.spec (фрагмент)
(пути подкорректируй под свой репо)

# Команда: pyinstaller -y build/KeySet.spec
block_cipher = None

a = Analysis(
    ['launcher.py'],
    pathex=['.'],
    datas=[
        ('frontend/dist', 'www'),                                 # статика SPA
        ('keyset/data/keyset.db', 'keyset/data'),                 # шаблон БД
        ('keyset/data/regions_tree_full.json', 'keyset/data'),    # GEO
        ('runtime/browsers', 'runtime/browsers'),                 # Playwright Chromium
        ('keyset/data/proxies.json', 'keyset/data'),              # дефолт конфиг (если есть)
    ],
    hiddenimports=[
        'uvicorn', 'fastapi', 'jinja2', 'playwright',
        'playwright._impl._driver', 'playwright._impl._transport',
        'playwright._impl._api_structures',  # чтобы не вырезало
    ],
    excludes=['numpy','pandas','matplotlib'],  # экономия размера
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
exe = EXE(
    pyz, a.scripts, a.binaries, a.zipfiles, a.datas,
    name='KeySet', console=False, icon='build/icon.ico'
)
coll = COLLECT(exe, a.binaries, a.zipfiles, a.datas, name='KeySet')

8) Копируем dist в www/ перед сборкой

Скрипт «одной кнопкой»:

REM 1) билдим фронт
cd frontend
npm run build
cd ..

REM 2) кладём dist в www
rmdir /S /Q www 2>nul
xcopy /E /I /Y frontend\dist www

REM 3) гарантируем браузер внутри проекта
set PLAYWRIGHT_BROWSERS_PATH=runtime\browsers
py -m playwright install chromium

REM 4) собираем exe
py -m pip install -r requirements.txt
py -m PyInstaller -y build\KeySet.spec

9) Самопроверка после сборки

Запусти KeySet\KeySet.exe.

Откроется окно; перейди на http://127.0.0.1:8765/api/health — должно быть 200 OK.

Убедись, что создались:

runtime\db\keyset.db (если не было — скопировался из шаблона),

runtime\profiles\ (после первого запуска парсера),

runtime\logs\ — есть логи.

Вкладки «Аккаунты» и «Данные» — без «Failed to fetch». Если пусто — это не сеть, а просто пустая БД (нормально).

10) Что можно смело удалить после сборки (экономим место)

node_modules/, .vite/, frontend/dist/ (если www/ уже создан и попал в exe);

виртуальное окружение .venv/ (если ставить не планируешь);

глобальный кэш Playwright: %LOCALAPPDATA%\ms-playwright\ (мы держим браузер в runtime/browsers/);

build/, dist/ от PyInstaller, кроме финальной папки с exe;

тестовые артефакты .pytest_cache/, __pycache__/.

Почему это закроет твои «хочу»

«всё в одном месте, могу почистить комп» — да, весь рантайм в KeySet/ (exe + runtime + www).

«ничего не разбросано» — профили, БД, браузер Playwright, geo, конфиги — все в runtime/.

«не ломаем парсер/ГЕО/React» — бизнес-код не меняем, только пути и упаковку.

«минимум телодвижений» — правки 3 файлов + spec; дальше одна команда сборки.

понял. Ничего не удаляем. Делаем «портативную» сборку так, чтобы всё лежало в одной папке рядом с .exe и сразу работало: БД, профили, браузер для парсера, GEO, конфиги, фронт. Вот готовый план + файлы. Скопируй/вставь — и запускай.

Что получим
KeySet/
├─ KeySet.exe
├─ runtime/
│  ├─ db/keyset.db           ← рабочая БД
│  ├─ profiles/              ← профили аккаунтов (user_data_dir)
│  ├─ browsers/              ← Chromium Playwright внутри проекта
│  ├─ geo/regions_tree_full.json
│  ├─ config/proxies.json  .env (если надо)
│  └─ logs/
└─ www/                      ← собранный React (frontend/dist)


После сборки можно отлаживать в этой папке. Ничего не чистим до твоей команды.

0) Один маленький модуль путей (центр всего)

Создай keyset/core/app_paths.py:

from __future__ import annotations
import os, sys, shutil
from pathlib import Path

# разрешаем указать корень приложения через переменную окружения для смоук-теста
ENV_APP_ROOT = os.environ.get("KEYSET_APP_ROOT")

def _app_root() -> Path:
    if ENV_APP_ROOT:
        return Path(ENV_APP_ROOT).resolve()
    if getattr(sys, 'frozen', False):
        return Path(sys.executable).resolve().parent
    # dev-режим: корень репо
    return Path(__file__).resolve().parents[3]

APP_ROOT = _app_root()
RUNTIME   = APP_ROOT / "runtime"
WWW_DIR   = APP_ROOT / "www"

DB_DIR     = RUNTIME / "db"
PROFILES   = RUNTIME / "profiles"
BROWSERS   = RUNTIME / "browsers"   # PLAYWRIGHT_BROWSERS_PATH
GEO_DIR    = RUNTIME / "geo"
CONFIG_DIR = RUNTIME / "config"
LOGS_DIR   = RUNTIME / "logs"

def ensure_runtime():
    for p in (DB_DIR, PROFILES, BROWSERS, GEO_DIR, CONFIG_DIR, LOGS_DIR):
        p.mkdir(parents=True, exist_ok=True)

def _bundle_dir() -> Path:
    return Path(getattr(sys, "_MEIPASS", APP_ROOT))

def bootstrap_files():
    """Копируем шаблоны в runtime при первом запуске"""
    ensure_runtime()
    # БД
    bundled_db = _bundle_dir() / "keyset" / "data" / "keyset.db"
    target_db  = DB_DIR / "keyset.db"
    if bundled_db.exists() and not target_db.exists():
        shutil.copy2(bundled_db, target_db)
    # GEO
    bundled_geo = _bundle_dir() / "keyset" / "data" / "regions_tree_full.json"
    target_geo  = GEO_DIR / "regions_tree_full.json"
    if bundled_geo.exists() and not target_geo.exists():
        shutil.copy2(bundled_geo, target_geo)
    # конфиги (если нужны дефолты)
    bundled_proxies = _bundle_dir() / "keyset" / "data" / "proxies.json"
    if bundled_proxies.exists() and not (CONFIG_DIR / "proxies.json").exists():
        shutil.copy2(bundled_proxies, CONFIG_DIR / "proxies.json")

def sqlite_url() -> str:
    return f"sqlite:///{(DB_DIR / 'keyset.db').as_posix()}"

Подключаем модуль

keyset/core/db.py

from sqlalchemy import create_engine
from .app_paths import bootstrap_files, sqlite_url

bootstrap_files()
engine = create_engine(sqlite_url(), connect_args={"check_same_thread": False})


Playwright/парсер (где инициализируешь браузер/профили):

import os
from keyset.core.app_paths import PROFILES, BROWSERS

os.environ["PLAYWRIGHT_BROWSERS_PATH"] = str(BROWSERS)

def profile_dir(account_id: int) -> str:
    d = PROFILES / f"acc_{account_id}"
    d.mkdir(parents=True, exist_ok=True)
    return str(d)
# дальше user_data_dir=profile_dir(acc.id)


FastAPI раздаёт SPA — один origin:

# backend/main.py (после include_router)
from fastapi.staticfiles import StaticFiles
from keyset.core.app_paths import WWW_DIR, ensure_runtime, bootstrap_files
ensure_runtime(); bootstrap_files()
app.mount("/", StaticFiles(directory=str(WWW_DIR), html=True), name="static")


Фронтенд API-клиент — без хардкода:

// axios/fetch
const api = axios.create({ baseURL: "/api" });

1) Лаунчер (Edge в app-режиме, один порт)
# launcher.py
import subprocess, sys, time
from keyset.core.app_paths import APP_ROOT

PORT = "8765"

backend = subprocess.Popen([
    sys.executable, "-m", "uvicorn", "backend.main:app",
    "--host", "127.0.0.1", "--port", PORT, "--log-level", "warning"
], cwd=str(APP_ROOT), stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)

time.sleep(1.5)  # можно заменить на health-check

subprocess.Popen([
    "msedge", f"--app=http://127.0.0.1:{PORT}/",
    rf"--user-data-dir={APP_ROOT}\runtime\edge_profile",
    "--disable-extensions", "--disable-plugins"
], cwd=str(APP_ROOT))

2) Ассемблер (собирает всё в одну папку и НИЧЕГО не удаляет)

Создай build\assemble_portable.bat:

@echo off
setlocal enableextensions

REM 0. Чистим только staging-папку (исходники не трогаем)
rmdir /S /Q out 2>nul
mkdir out\KeySet\runtime\db
mkdir out\KeySet\runtime\profiles
mkdir out\KeySet\runtime\browsers
mkdir out\KeySet\runtime\geo
mkdir out\KeySet\runtime\config
mkdir out\KeySet\runtime\logs
mkdir out\KeySet\www

REM 1. Собираем фронт и кладём в www
pushd frontend
call npm run build || goto :err
popd
xcopy /E /I /Y frontend\dist out\KeySet\www >nul

REM 2. Готовим браузер Playwright ВНУТРИ проекта
set PLAYWRIGHT_BROWSERS_PATH=out\KeySet\runtime\browsers
py -m pip install --disable-pip-version-check playwright >nul
py -m playwright install chromium >nul

REM 3. Копируем шаблон БД/geo/конфиги (если есть)
if exist keyset\data\keyset.db xcopy /Y keyset\data\keyset.db out\KeySet\keyset\data\ >nul
if exist keyset\data\regions_tree_full.json xcopy /Y keyset\data\regions_tree_full.json out\KeySet\keyset\data\ >nul
if exist keyset\data\proxies.json xcopy /Y keyset\data\proxies.json out\KeySet\keyset\data\ >nul

REM 4. Смоук-тест без сборки: поднимаем бекенд на out\KeySet как APP_ROOT
set KEYSET_APP_ROOT=%cd%\out\KeySet
start "" /B py -c "import uvicorn,os;os.environ['KEYSET_APP_ROOT']=r'%KEYSET_APP_ROOT%';from backend.main import app; uvicorn.run(app,host='127.0.0.1',port=8765,log_level='warning')" 
timeout /t 2 >nul
powershell -command "$r=iwr http://127.0.0.1:8765/api/health -UseBasicParsing; if($r.StatusCode -ne 200){exit 1}"
if errorlevel 1 goto :err
powershell -command "$r=iwr http://127.0.0.1:8765/ -UseBasicParsing; if($r.StatusCode -lt 200 -or $r.StatusCode -ge 400){exit 1}"
if errorlevel 1 goto :err
taskkill /FI "WINDOWTITLE=uvicorn*" /F >nul 2>&1

echo OK: portable assembled in out\KeySet
exit /b 0

:err
echo BUILD ERROR. Check logs above.
exit /b 1


Скрипт ничего не удаляет в исходниках. Он делает staging в out\KeySet\ и сразу проверяет, что API и SPA отвечают из этой папки (через KEYSET_APP_ROOT). Если тест не прошёл — останавливаемся, ничего не удаляем.

3) PyInstaller (кладём exe в ту же папку)

build/KeySet.spec (коротко):

# pyinstaller -y build/KeySet.spec
block_cipher=None
import os
APP_ROOT=os.path.abspath("out/KeySet")  # собираем прямо из staging

a = Analysis(
    ['launcher.py'],
    pathex=[APP_ROOT],
    datas=[
        (os.path.join(APP_ROOT,'www'),'www'),
        (os.path.join(APP_ROOT,'runtime','browsers'),'runtime/browsers'),
        ('keyset/data/keyset.db','keyset/data'),
        ('keyset/data/regions_tree_full.json','keyset/data'),
        ('keyset/data/proxies.json','keyset/data'),
    ],
    hiddenimports=['uvicorn','fastapi','jinja2','playwright','playwright._impl._driver',
                   'playwright._impl._transport','playwright._impl._api_structures'],
    excludes=['numpy','pandas','matplotlib'],
)
pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)
exe = EXE(pyz, a.scripts, a.binaries, a.zipfiles, a.datas, name='KeySet', console=False, icon='build/icon.ico')
coll = COLLECT(exe, a.binaries, a.zipfiles, a.datas, name='KeySet')

4) Как запускать всё это (без удаления чего-либо)

build\assemble_portable.bat — получишь out\KeySet\ с полным рантаймом и пройденным смоук-тестом.

py -m PyInstaller -y build\KeySet.spec — положит KeySet.exe рядом (в dist\KeySet\ или перенеси в out\KeySet\).

Стартуй out\KeySet\KeySet.exe.

Открой «Аккаунты/Данные» — запросы идут на http://127.0.0.1:8765, БД — runtime\db\keyset.db, профили — runtime\profiles\…, браузер — runtime\browsers\….

Контрольный чек-лист (что должно быть до отладки)

 out\KeySet\www\index.html и assets/* на месте.

 out\KeySet\runtime\db\keyset.db после первого запуска появился.

 out\KeySet\runtime\browsers\ не пустая (есть Chromium).

 GET http://127.0.0.1:8765/api/health → 200.

 «Аккаунты/Данные» без «Failed to fetch».

 Парсер стартует, профили пишутся в runtime\profiles\acc_*.

Хочешь — пришлю готовые DIFF-вставки сразу под твои файлы (app_paths.py, изменения в db.py/main.py, launcher.py, батник и .spec). Всё это работает без удаления чего-либо: сначала собираем «портативку» и прогоняем смоук-тест, только потом уже, когда скажешь, можно будет чистить старое.