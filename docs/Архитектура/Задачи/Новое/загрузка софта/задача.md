Упаковка React-приложения в FastAPI как SPA

Первым шагом будет встроить скомпилированный фронтенд (React/Vite) в бэкенд FastAPI, чтобы он раздавался как единая SPA. В проекте KeySet-MVP это уже частично предусмотрено: в backend/main.py есть условный монтинг статики:

# backend/main.py
from fastapi.staticfiles import StaticFiles

FRONTEND_DIST = BASE_DIR.parent / "frontend" / "dist"
if FRONTEND_DIST.exists():
    app.mount("/", StaticFiles(directory=FRONTEND_DIST, html=True), name="frontend")


Действия:

Собрать фронтенд: Выполните npm run build (или pnpm run build) в папке frontend. Это создаст папку frontend/dist с файлами index.html и папкой assets/. Убедитесь, что сборка прошла успешно и содержит все необходимые бандлы.

Скопировать сборку в backend: Поместите содержимое frontend/dist в статическую директорию бэкенда. Например, вы можете настроить FastAPI на раздачу прямо из frontend/dist, как указано выше. В текущей архитектуре код уже монтирует эту директорию на корень приложения ("/"), что идеально для SPA. Убедитесь, что файл index.html находится именно в этой директории и доступен для StaticFiles.

Почему это нужно: Это позволит открывать приложение по URL бэкенда (например, http://127.0.0.1:8765/) и получать сразу загруженный React UI. Параметр html=True в StaticFiles включает SPA-фолбек: любые неизвестные маршруты (например, /accounts или /data при навигации внутри React Router) будут отдавать index.html вместо 404. Так мы не “ломаем” клиентский роутинг.

Проверка маршрутов: Убедитесь, что все API-ендпоинты бэкенда смонтированы с префиксом (в проекте используется префикс /api, как видно из документации и кода роутеров). Это предотвратит конфликт путей: StaticFiles обслуживает корневой маршрут, а все запросы, начинающиеся с /api, продолжат обрабатываться FastAPI. В коде FastAPI сначала включаются роутеры, затем монтируется статика – это гарантирует, что запросы к /api/... не перехватываются StaticFiles, а идут в соответствующие роутеры. Например, вызов GET /api/health должен по-прежнему идти в роут бэкенда, а GET /accounts – отдаваться как индексный HTML (SPA).

Настройка Vite (если потребуется): По умолчанию Vite собирает проект с базовым путём “/”. Это видно в index.html сборки – ссылки на скрипты и фавикон начинаются с /<...>. Поскольку мы раздаём фронтенд с корня домена, менять ничего не нужно. Важно: если бы статику пришлось монтировать не на корень (например, на /app/), тогда потребовалось бы добавить в Vite-конфиг параметр base: "/app/" и пересобрать, чтобы ссылки в index.html корректно указывали на /app/assets/.... В нашей ситуации React-приложение будет доступно прямо с корня (http://127.0.0.1/), поэтому дополнительная настройка не нужна. Просто убедитесь, что файлы вроде vite.svg и бандлы в assets/ доступны по своим путям.

Изменения в маршрутах и конфигурации

Существующая структура бэкенда уже близка к нужной: не требуется переписывать API-роуты или логику FastAPI, достаточно настроить статическую раздачу. Убедитесь, что:

Подключение статики происходит после объявления роутеров. В backend/main.py включение роутеров (например, app.include_router(...)) должно вызываться до app.mount("/"). В противном случае StaticFiles может перехватить запросы к API. Проверьте порядок: сначала app = FastAPI(), затем app.include_router(...) для всех /api маршрутов, и только в конце – монтирование статики. Это соответствует best-practice и уже реализовано.

В конфигурации FastAPI указан app.mount("/", StaticFiles(..., html=True)). Если этого фрагмента не было бы, нужно его добавить. Однако, судя по загруженным файлам, он присутствует. Вам следует лишь убедиться, что путь FRONTEND_DIST правильно указывает на конечную сборку. Например, если вы решите копировать файлы в backend/static, то используйте StaticFiles(directory="backend/static", html=True). В проекте же используется путь к frontend/dist в корне репозитория – это тоже работает, т.к. при сборке .exe мы включим эти файлы.

Переменные окружения или режим разработки отключены: Убедитесь, что фронтенд обращается к API по относительным путям. В коде React (см. например, frontend/src/modules/accounts/api.ts или интеграцию в 10_API_INTEGRATION.md) вызовы идут на /api/..., без хардкода хоста. Это означает, что в продакшен-сборке UI будет стучаться на тот же хост/порт, откуда загружена страница – то есть наш FastAPI. Это правильно. Нет необходимости прописывать в React конкретный порт или использовать прокси – при встроенной раздаче фронтенда всё происходит с одного источника (origin), и проблемы с CORS или авторизацией по кукам отсутствуют.

Файлы конфигураций и данные: Убедитесь, что при сборке все необходимые статические файлы бэкенда тоже будут доступны. Например, упоминался файл regions.json (дерево регионов для GeoSelector). Бэкенд загружает его при старте (в keyset/data/regions_tree_full.json), и он уже добавлен в datas PyInstaller-спека. В SPA-режиме ничего менять не нужно – API /api/regions продолжит читать свой JSON, а фронтенд по-прежнему получит данные через этот эндпоинт. Не удаляйте и не перемещайте файлы с данными – сохраните их структуру (keyset/data/..., backend/keyset.db, backend/config/...) при упаковке. Это гарантирует, что гео-дерево, cookie и другие части (CDP-патчинг регионов) будут работать, как и раньше.

Launcher с Edge --app режимом

Главное изменение нужно внести в запускающий скрипт (launcher.py). Нам нужно сделать так, чтобы:

Окно UI открывалось мгновенно через Edge в режиме приложения (без адресной строки и вкладок).

Избежать фиксированных локальных портов (типа 5173, 8765), чтобы при запуске .exe не было конфликта и не появлялось лишних слушателей в системе.

Решение – использовать уже установленный браузер (Edge или Chrome) в режиме Application (без адресной строки и вкладок). Это даст пользователю отдельное окно приложения, выглядящее как нативное десктопное приложение.

Шаг 2 – Динамический выбор порта: Заранее выделим свободный порт для бэкенда, чтобы не использовать жестко 8765. Например:

import socket
BACKEND_HOST = "127.0.0.1"
# Найти свободный порт
with socket.socket() as sock:
    sock.bind((BACKEND_HOST, 0))
    BACKEND_PORT = sock.getsockname()[1]


Это привяжет сокет к localhost на случайном свободном порту, получив номер через sock.getsockname()[1]. Затем освобождаем сокет (он закроется по выходу из with-блока). Так мы гарантируем, что порт свободен и зарезервирован на момент запуска (риск коллизии минимален). Далее используйте этот BACKEND_PORT при старте Uvicorn.

Шаг 3 – Запуск бэкенда в фоне: Как и раньше, запускаем FastAPI-сервер в отдельном потоке, но теперь с выбранным портом и без режима reload (в .exe он не нужен). Можно использовать либо uvicorn.run, либо низкоуровневый Server(Config(...)).run(). Например:

import threading, time
from uvicorn import Config, Server

def start_backend():
    config = Config("backend.main:app", host=BACKEND_HOST, port=BACKEND_PORT, log_level="info")
    Server(config).run()

# Запустить бэкенд-поток
thread = threading.Thread(target=start_backend, daemon=True)
thread.start()
# Подождать, пока сервер поднимется (например, 1 секунда)
time.sleep(1.0)


Можно снизить задержку до ~0.5-1.0с для ускорения старта. Optionally, более точно – реализовать проверку: пытаться подключиться к http://127.0.0.1:PORT/api/health в цикле с небольшим интервалом, чтобы не ждать дольше необходимого. Но 1 секунды обычно достаточно, чтобы Uvicorn поднялся.

Шаг 3 – Открытие окна UI: Воспользуемся установленным браузером в режиме приложения. На Windows почти наверняка есть Microsoft Edge (Chromium). Мы можем вызвать его с параметром --app=:

import subprocess, sys, webbrowser

url = f"http://{BACKEND_HOST}:{BACKEND_PORT}"
try:
    subprocess.Popen(["msedge", "--app=" + url])
except FileNotFoundError:
    try:
        subprocess.Popen(["chrome", "--app=" + url])
    except FileNotFoundError:
        webbrowser.open(url)


Этот код попытается запустить Edge в режимe приложения (без вкладок и адресной строки). Если Edge не найден (маловероятно на Win10/11, но на всякий случай), пробует Chrome в таком же режиме. Если и Chrome не найден, в крайнем случае откроет URL в браузере по умолчанию (через webbrowser.open).

Шаг 4 – Завершение процесса правильно: В режиме --app открывается отдельное окно/процесс браузера. Мы можем дождаться его завершения, чтобы затем завершить и наше приложение. Например:

proc = subprocess.Popen([...])
proc.wait()  # Блокируем основной поток до закрытия браузерного окна


Так, когда пользователь закроет окно UI, proc.wait() разблокируется. После этого можно аккуратно завершить бекенд. Поскольку бекенд-поток мы запускали как daemon, при выходе из главного потока он прервется автоматически. Чтобы завершение было чистым, можно вручную остановить Uvicorn сервер – но API у uvicorn.Server для стопа нет простого, поэтому принимаем, что daemon-thread просто завершится. После proc.wait() можно вызывать sys.exit(0) или просто дать программе завершиться. Этот подход гарантирует отсутствие фоновых процессов после закрытия окна приложения.

Итоговые правки в launcher.py:

Добавить импорт socket, subprocess, webbrowser.

Установить BACKEND_HOST = "127.0.0.1" и вычислять BACKEND_PORT динамически, как показано выше, вместо жесткого значения 8765.

Использовать Config/Server или uvicorn.run с полученным портом для запуска FastAPI.

После старта бэкенда – вызвать subprocess.Popen для Edge/Chrome с полными путями к exe файлам.

После запуска окна – заблокировать главный поток на ожидание закрытия (proc.wait()), затем завершить программу.

Пример: обновленный псевдокод launcher.py:

import socket, subprocess, webbrowser, threading, time
from uvicorn import Config, Server

BACKEND_HOST = "127.0.0.1"
# pick free port
with socket.socket() as s:
    s.bind((BACKEND_HOST, 0))
    BACKEND_PORT = s.getsockname()[1]

def start_backend():
    config = Config("backend.main:app", host=BACKEND_HOST, port=BACKEND_PORT, log_level="info")
    Server(config).run()

# Start backend thread
thread = threading.Thread(target=start_backend, daemon=True)
thread.start()
time.sleep(1.0)  # wait for server up

# Launch UI in Edge/Chrome app-mode
url = f"http://{BACKEND_HOST}:{BACKEND_PORT}"
try:
    proc = subprocess.Popen(["msedge", "--app=" + url])
except FileNotFoundError:
    try:
        proc = subprocess.Popen(["chrome", "--app=" + url])
    except FileNotFoundError:
        proc = None
        webbrowser.open(url)
if proc:
    proc.wait()
# When window closes, exit launcher (daemon thread will terminate)


Эти изменения не требуют локального dev-сервера (Vite не нужен – мы работаем с готовой сборкой). Также мы не держим постоянный фиксированный порт: порт выбирается динамически. Заметьте: хотя мы все еще используем HTTP для связи фронта и бэка, сокет слушается только на 127.0.0.1 (локально) и на случайном порту – т.е. ни один внешний порт не занят, и при повторном запуске не будет конфликта. Пользователь этого не заметит, т.к. приложение само открывает нужный URL в отдельном окне без адресной строки.

Сборка PyInstaller: единый .exe

Чтобы получить единый исполняемый файл, настроим PyInstaller соответствующим образом:

Spec-файл или команда: В документации приведён пример build/keyset.spec. Нужно убедиться, что в нём указаны все нужные файлы. Обратите внимание на блок datas: там уже добавлены *collect_frontend() (папка фронтенда), папка keyset (включая keyset/data/regions_tree_full.json), и скрытые импорты (playwright._impl._backend, uvicorn, fastapi etc.).

Учтите подключение launcher: В spec-файле в Analysis указывается список входных скриптов – в примере это ['launcher.py']. PyInstaller будет упаковывать launcher с Edge --app решением.

Установите флаг сборки одного файла. Если используете .spec, это делается при вызове команды: pyinstaller --onefile build/keyset.spec. Если .spec не используется, можно настроить EXE(..., exclude_binaries=False) и colllect правила, но проще через параметр CLI. В одном файле все данные окажутся внутри .exe (упакованные в bootloader).

Включение файлов БД и конфигурации: Важно, чтобы SQLite-база и JSON-конфиги попали в сборку. В примере spec они не явно указаны, но финальная структура dist/ указывает на наличие keyset.db и regions.json. Это значит, что процесс сборки (скрипт scripts/package.py или Installer) копировал их отдельно. Для truly one-file мы должны включить их заранее:

Добавьте путь к backend/keyset.db в datas списка PyInstaller. Например: datas=[(...), (str(project_root / 'backend' / 'keyset.db'), '.') ]. Здесь второй элемент '.' означает, что файл будет помещён в корень сборки. Можно поместить его, например, в ту же директорию, что и бинарник, но в onefile это не имеет значения.

Аналогично, если есть backend/regions.json (или keyset/config/proxies.json и т.д.), добавьте их. Проект уже включал regions_tree_full.json (для дерева регионов), но в итоговом дистрибутиве был файл regions.json. Возможно, regions.json – результат преобразования или другой формат. Если он нужен, добавьте и его.

Использование встроенных данных при запуске: One-file режим PyInstaller распаковывает содержимое во временную папку при старте (доступную через sys._MEIPASS). Нам нужно учесть это в коде:

Статические файлы фронтенда: В FastAPI монтируется FRONTEND_DIST как Path(__file__).parent.parent / 'frontend/dist'. В замороженном exe такой путь не существует на диске. Однако, благодаря тому, что мы добавили frontend/dist в datas, PyInstaller распакует папку frontend во временное хранилище. Простое решение – определить путь к статике динамически:

import sys
if getattr(sys, 'frozen', False):
    # В режиме сборки путь к static через _MEIPASS
    static_dir = Path(sys._MEIPASS) / 'frontend' / 'dist'
else:
    static_dir = FRONTEND_DIST  # как раньше, для dev-режима
app.mount("/", StaticFiles(directory=static_dir, html=True), name="frontend")


Вставьте эту логику в backend/main.py вместо прямого использования FRONTEND_DIST. Таким образом, при запуске .exe приложение найдёт index.html в распакованных ресурсах.

База данных: SQLite-файл не должен оставаться только внутри .exe, иначе изменения не сохранятся между запусками. Мы включили keyset.db в сборку, но при каждом старте он будет распакован заново во временную папку, и все изменения пропадут при выходе. Решение – скопировать базу в постоянное место. Можно выбрать папку рядом с .exe или, лучше, в %APPDATA%/KeySet/ пользователя. Для простоты предположим, что рядом с .exe (текущая рабочая директория) – так пользователю понятнее (он сможет найти файл базы, если нужно). Реализуем так в коде запуска:

import shutil, os
if getattr(sys, 'frozen', False):
    bundle_dir = Path(sys._MEIPASS)
    bundled_db = bundle_dir / 'backend' / 'keyset.db'  # исходный файл в пакете
    target_db = Path(os.getcwd()) / 'keyset.db'
    if not target_db.exists():
        shutil.copy2(bundled_db, target_db)
    # Обновим путь в настройках, чтобы SQLAlchemy использовал внешний файл:
    DB_PATH = target_db


Это можно вставить в начало backend/db.py до создания engine. В вашем коде DB_PATH определяется как BASE_DIR/"keyset.db". Нужно изменить логику: если обнаружено, что работаем из сборки, переопределить DB_PATH на внешний файл (скопировав его при необходимости). После этого строка create_engine(f"sqlite:///{DB_PATH}", ...) будет открывать/создавать файл в рабочей директории, а не внутри темпа. Важно: убедитесь, что права на запись у этого каталога есть (для Program Files лучше использовать %APPDATA%). Но если .exe не устанавливается в Program Files, а запускается из произвольной папки, записи рядом с ним достаточно.

Альтернативно, можно не включать keyset.db в один файл, а поставлять его рядом – но это нарушит требование “всё внутри .exe”. Поэтому рекомендуемый подход – копирование на первый запуск.

Файлы конфигов (JSON, логотипы и др.): Если они используются только для чтения, их можно читать прямо из распакованных _MEIPASS. Например, regions_tree_full.json можно открыть по аналогичному принципу:

data_path = Path(sys._MEIPASS) / 'keyset' / 'data' / 'regions_tree_full.json'
with open(data_path, 'r', encoding='utf-8') as f:
    regions_data = json.load(f)


Если же какой-то JSON должен сохраняться (например, proxies.json может изменяться?), то стоит аналогично копировать его наружу. Судя по структуре, proxies.json и regions.json скорее читаются, чем модифицируются, так что их можно оставить внутри .exe. Просто проверьте, как backend их загружает – если через относительный путь, возможно, надо поправить на использование _MEIPASS аналогично базе.

Сборка .exe: Запустите PyInstaller со спецификацией. Например:

pyinstaller --onefile build/keyset.spec


Убедитесь, что в выводе не было ошибок о missing module. В случае чего, добавьте недостающие модули в hiddenimports. (В документации указано добавить pywin32 для Win32 API, но если вы не используете явные win32calls, можно пропустить. Однако, PyInstaller иногда требует pywin32 для корректной работы subprocess/console – проверьте).

По завершении вы получите единый файл, условно dist/KeySet.exe (название задаётся в spec: name='KeySetLauncher' – можете поменять). Запустив его, вы должны увидеть, что:

Мгновенно появляется окно приложения (Edge или Chrome в режиме приложения, либо встроенное окно, в зависимости от выбранного пути). Не появляется консоль (в spec console=False).

В течение ~1 секунды подгружаются UI-вкладки. Интерфейс React должен работать как прежде: переключение вкладок, модалки GeoSelector, стили – всё на месте, т.к. мы использовали ту же сборку фронтенда без изменений.

Бэкенд функционирует полноценно: попробуйте выполнить основные сценарии (создать аккаунт, импортировать CSV, запустить парсинг – возможно, в офлайн-режиме парсер отдаст мок-данные). Все API /api/... вызовы должны успешно выполняться.

Проверьте, что база данных сохраняет изменения. Например, добавленный аккаунт должен остаться в keyset.db между перезапусками приложения. Для уверенности можно открыть/прочитать этот файл вне программы. Если изменения не сохраняются, убедитесь, что вы правильно реализовали копирование БД во внешний файл и что SQLAlchemy действительно пишет в него (можно добавить временно логирование echo=True).

Устранение возможных мелких проблем:

Блокировка БД: В документации отмечалась ошибка "Database locked" при повторном запуске нескольких экземпляров. Наш подход с динамическим портом позволяет запустить два экземпляра (они возьмут разные порты). Однако, оба экземпляра попытались бы писать в один и тот же keyset.db на диске – это вызовет lock SQLite. Чтобы этого избежать, можно запретить запуск второй копии или использовать разные пути для БД. Проще – не допускайте параллельный запуск: например, можно при старте проверять наличия запущенного процесса (сложнее) или открывать БД в WAL-режиме. В keyset/core/db.py можно выполнить engine.execute("PRAGMA journal_mode=WAL;") сразу после создания engine – тогда чтение/запись из двух процессов будет безопаснее, хотя всё равно не рекомендуется. В рамках минимальных изменений это не строго обязательно, но рекомендуется включить WAL, как советовали в документации.

Логи и временные файлы: Если в проекте есть логирование (logs/app.log упоминался), убедитесь, что логи пишутся в доступное место. Можно настроить logging в файл рядом с .exe или в %LOCALAPPDATA%. Главное – без попыток писать во временную папку PyInstaller (она удаляется). Аналогично, Playwright при первом запуске может пытаться скачать Chromium – но в вашем случае вы уже включили его в сборку (через npx playwright install chromium). Убедитесь, что при запуске офлайн Playwright не хочет ничего догружать. Можно установить переменные окружения для Playwright, указывающие использовать встроенный браузер. Обычно, PyInstaller с Playwright требует скопировать папку с браузером. Судя по spec, вы включили 'playwright._impl._backend' – этого достаточно для кода, но сам бинарник Chromium (в %USERPROFILE%\.cache\ms-playwright\) нужно либо оставить на месте, либо копировать. Проверьте на чистой машине: если парсинг не запускается из-за отсутствия браузера, придётся либо запускать playwright install при инсталляции, либо включить папку Chromium в установщик (Inno Setup script может это сделать).

Env и Dev режимы: Если где-то в коде проверяется флаг debug/dev (например, if __debug__: или переменная окружения), убедитесь, что в продакшене ничего лишнего не выполняется. Например, launcher.py --devtools упоминалось: мы можем поддержать аргумент --devtools для отладки (например, вместо proc = subprocess.Popen([...]) открыть браузер с devtools). Но это не критично, можно опустить.

Минимальные правки и сохранение функциональности

Ниже перечислим конкретно, что и где изменить, чтобы собрать всё воедино без потери возможностей:

Файл frontend/vite.config.js (при необходимости): убедитесь, что параметр base соответствует пути раздачи. В нашем случае оставляем по умолчанию ("/"). Это означает, что после сборки пути в index.html будут начинаться с "/", и при монтировании статики на корень они корректно загрузятся. Если бы статика была не на корне, нужно было бы изменить base. В текущей архитектуре менять не надо.

Файл backend/main.py: добавить логику выбора пути к статике при заморозке. Например:

import sys
from pathlib import Path
from fastapi.staticfiles import StaticFiles

BASE_DIR = Path(__file__).resolve().parent
if getattr(sys, 'frozen', False):
    static_dir = Path(sys._MEIPASS) / "frontend" / "dist"
else:
    static_dir = BASE_DIR.parent / "frontend" / "dist"
if static_dir.exists():
    app.mount("/", StaticFiles(directory=static_dir, html=True), name="frontend")


Также, убедитесь, что подключение API-роутеров происходит до этого блока. Например:

from backend import routers  # условно, импорт регистрации роутов
app.include_router(routers.accounts, prefix="/api/accounts")
... (подключение остальных роутеров) ...
# После всех роутеров:
app.mount("/", StaticFiles(...))


Если роуты подключаются в других местах, сохраните их порядок.

Файл backend/db.py (или где создаётся движок SQLite): внедрите логику копирования базы на внешний путь. Конкретно, сразу после определения DB_PATH = BASE_DIR / "keyset.db", вставьте:

import sys, shutil, os
if getattr(sys, 'frozen', False):
    bundle_dir = Path(sys._MEIPASS)
    bundled_db = bundle_dir / "backend" / "keyset.db"
    external_db = Path(os.getcwd()) / "keyset.db"
    if not external_db.exists():
        shutil.copy2(bundled_db, external_db)
    DB_PATH = external_db


Затем уже идёт engine = create_engine(f"sqlite:///{DB_PATH}", echo=False). Таким образом, при первом запуске .exe в текущей папке появится файл keyset.db (скопированный из пакета), и дальше все операции будут идти в него. В последующих запусках копирования не произойдёт (файл уже существует, мы его не трогаем, сохраняя данные).
Примечание: Если хотите, можно вместо os.getcwd() выбрать фиксированное место (например, всегда класть в %APPDATA%\KeySet\keyset.db). Тогда стоит вычислить путь через os.getenv("APPDATA") или Path.home(). Но это уже предпочтение; рядом с exe – проще отладить.

Файл launcher.py: основная точка изменений:

Добавьте импорты: import socket, subprocess, webbrowser, threading, time, sys, pathlib.

Задайте BACKEND_HOST = "127.0.0.1" и не фиксируйте BACKEND_PORT, а вычислите (как было показано выше) через сокет.

Функцию start_backend можно оставить, изменив uvicorn.run(...) на запуск через Config. Либо оставить uvicorn.run – но учтите, что uvicorn.run внутри себя блокирует поток, поэтому если вы вызываете её без нового потока, приложение зависнет на бэкенде. Нам важно запускать сервер в отдельном потоке, как у вас и сделано. Так что:

def start_backend():
    uvicorn.run("backend.main:app", host=BACKEND_HOST, port=BACKEND_PORT, log_level="info")


(Можно и Config/Server, но uvicorn.run проще и тоже работает в отдельном треде).

Реализуйте запуск браузера в Edge --app режиме с полными путями к exe файлам:

# Запустить бэкенд-поток
thread = threading.Thread(target=start_backend, daemon=True)
thread.start()
time.sleep(1.0)
# Открыть URL
url = f"http://{BACKEND_HOST}:{BACKEND_PORT}"
try:
    proc = subprocess.Popen(["msedge", "--app=" + url])
except FileNotFoundError:
    try:
        proc = subprocess.Popen(["chrome", "--app=" + url])
    except FileNotFoundError:
        proc = None
        webbrowser.open(url)
if proc:
    proc.wait()


Обратите внимание: флаг daemon=True у потока бэкенда означает, что когда основной поток завершится, background-тред прервётся автоматически. Это удобно для нашего случая – не нужно специально убивать Uvicorn, он завершится, когда приложение закроется.

Удалите строку запуска PyWebView (webview.start()) и все связанные печати логов, чтобы они не отвлекали. Можно оставить print с сообщением, что запускается Edge/Chrome, для отладки. В финальной версии они не критичны.

Spec-файл PyInstaller (build/keyset.spec): внесите изменения для one-file:

В секции a = Analysis(...) добавьте запись для базы данных и других файлов. Например:

datas=[  
    (str(project_root / 'keyset'), 'keyset'),  
    (str(project_root / 'keyset' / 'data' / 'regions_tree_full.json'), 'keyset/data'),  
    (str(project_root / 'backend' / 'keyset.db'), 'backend'),  
    (str(project_root / 'backend' / 'regions.json'), 'backend'),  
    *collect_frontend(),  
],  


Здесь мы включаем папку keyset (с кодом и, возможно, шаблонами/моделями), JSON с деревом регионов, файл базы и файл регионов (если есть). Путь 'backend' во втором элементе кортежа означает, что при распаковке эти файлы окажутся в папке backend внутри _MEIPASS (мы так планировали в коде). Важно: Указывайте правильные пути: например, если regions.json лежит в корне репозитория, а не в папке backend, то нужно (str(project_root / 'regions.json'), '.'). Проверьте фактическое расположение. Согласно документам, regions.json может находиться в backend/regions.json или в keyset/config/regions.json. Поместите его в ту же папку, где ожидает код.

Установите в конфигурации сборки флаг onefile. Если вы используете spec, то вместо вызова EXE(...) нужно использовать команду pyinstaller --onefile keyset.spec. Либо в spec добавить:

exe = EXE(..., upx=True, console=False, name="KeySet", onefile=True)


Однако, в стандартном шаблоне spec неявно onefile управляется командой. Проще – запускать PyInstaller командой с параметром.

Проверьте hiddenimports. Мы убрали PyWebView, значит можно удалить 'pywebview' из зависимостей, если он был. Добавлять что-либо специально не нужно, так как мы используем стандартные модули (socket, subprocess, etc.). Если выбрали встроенный веб-движок, придётся добавить его модули и учесть копирование GUI-плагинов, но это выходит за рамки минимальных изменений. С Edge/Chrome этого не надо.

Установочный скрипт (Inno Setup) (если используете): Ранее Inno копировал папку frontend, exe-шники и JSON. Теперь у нас всё упаковано в один .exe, кроме, возможно, базы данных. Решите, как вы будете распространять базу:

Вариант 1: Не включать базу в .exe, а класть её рядом при установке. Тогда Inno Setup должен по-прежнему копировать keyset.db отдельно в папку установки. В этом случае вам не нужен код копирования БД – приложение сразу будет работать с внешним файлом. Но тогда дистрибутив – это 2 файла (exe + db).

Вариант 2 (рекомендуется): Включить базу в .exe и копировать на первый запуск. Тогда установщик может не класть keyset.db отдельно. При каждом запуске приложение само обеспечит наличие этого файла. Для безопасности можно даже при деинсталляции спрашивать, удалять ли базу (чтобы пользователь мог сохранить свои данные).
В любом случае, обновите keyset_installer.iss под новую структуру. Если один exe – то [Files] секция будет содержать только этот exe. Если база отдельно – добавьте её. В предыдущей версии:

Source: "dist\KeySetLauncher.exe"; DestDir: "{app}"
Source: "dist\keyset-backend.exe"; DestDir: "{app}"
Source: "dist\frontend\*"; DestDir: "{app}\frontend"
Source: "dist\regions.json"; DestDir: "{app}"


Теперь должно быть примерно:

Source: "dist\KeySet.exe"; DestDir: "{app}"
Source: "dist\keyset.db"; DestDir: "{app}"; Flags: ignoreversion


(Если решите класть базу). Если база внутри .exe, вторую строчку убрать.
Скорее всего, удобнее всё-таки доставлять базу отдельно, чтобы не заботиться о переносе данных между версиями .exe. Но раз задача – «единый .exe», мы предполагаем, что вы выберете вариант с копированием на запуск и не будете класть базу в инсталляторе.

После внесения этих изменений, выполните полный цикл сборки: npm run build → pyinstaller ... → (Inno Setup, если нужно). Протестируйте получившийся файл на чистой машине без установленного Node/Python и без доступа к Интернету: приложение должно открыться менее чем за секунду и работать автономно. Все функции – UI вкладки, парсинг через Playwright (CDP), выбор гео, сохранение данных – должны остаться без изменений.

Важно: Мы практически ничего не изменяли в самом коде приложения (ни в React, ни в FastAPI логике). Изменения касаются только способа упаковки и запуска. Таким образом, не нарушена работа UI и backend:

UI (React) – развернут тот же build, с теми же вкладками, модалками (GeoSelector) и code-splitting, что и раньше. Мы не трогаем исходники React, поэтому модульная структура (Accounts/Data/Masks/Analytics) и Zustand-хранилища сохраняются.

Backend (FastAPI + Playwright) – запускается внутри .exe, обрабатывает API-запросы как раньше. CDP-парсинг (через Playwright) будет работать, если Chromium доступен. Убедитесь, что Playwright видит Chromium: либо включите его в инсталлятор, либо выполните playwright install при первом запуске. В оффлайн-режиме, если Chromium не найден, парсинг может упасть – это отдельный момент: можно заранее скачать нужные файлы. Но сам механизм (запуск Chrome с патчингом запросов под нужный region_id) мы не меняли, он должен работать.

Geo patching и geotree: Функциональность выбора региона тоже не страдает – файл regions_tree_full.json включён, endpoint /api/regions отдаёт данные для GeoSelector, фронтенд и backend синхронизованы по ID регионов. Мы лишь должны убедиться, что этот JSON читается из правильного места (см. выше про _MEIPASS), но судя по тому, что мы положили его в keyset/data внутри пакета и не изменяли код чтения, всё будет хорошо.

Подводя итог, минимальные правки сводятся к:

Настройке раздачи статического фронтенда в FastAPI (код уже был, мы лишь адаптировали под onefile).

Удалению зависимости PyWebView и переходу на запуск браузера в app-режиме (правки в launcher.py).

Динамическому выбору порта вместо жесткого, чтобы избежать конфликтов и лишних портов.

Настройке PyInstaller для единого файла и включения всех необходимых данных (статик-файлы, БД, JSON).

Небольшим правкам для работы с файлами в режиме frozen (поиск _MEIPASS, копирование БД).

Каждый из этих шагов сохраняет существующую архитектуру приложения: React-frontend + FastAPI-backend + SQLite + Playwright объединяются в одном исполняемом файле, который запускается без внешних зависимостей. Пользователю не нужно открывать браузер вручную, не нужно запускать отдельные сервисы – достаточно двойного клика по .exe. Приложение быстро стартует (появляется окно сразу, UI загружается за доли секунды из локальных ресурсов) и стабильно работает офлайн. Все требования выполнены: ни Electron, ни Eel, ни PyWebView больше не используются, а оригинальный UI/UX KeySet-MVP полностью сохранён.

GPT дал ПРАВИЛЬНОЕ РЕШЕНИЕ, но переусложнил объяснение. Вот что реально нужно сделать:
Суть решения GPT (без воды):
1. Собрать React в статику и встроить в FastAPI
bashDownloadCopy codecd frontend
npm run build
# Создастся frontend/dist с index.html и assets/
2. FastAPI раздает эту статику (у тебя УЖЕ есть в main.py):
pythonDownloadCopy code# backend/main.py - УЖЕ ЕСТЬ
if (BASE_DIR.parent / "frontend" / "dist").exists():
    app.mount("/", StaticFiles(directory="frontend/dist", html=True), name="frontend")
3. Новый launcher.py БЕЗ PyWebView:
pythonDownloadCopy codeimport socket
import subprocess
import threading
import time
import sys

# Находим свободный порт
with socket.socket() as s:
    s.bind(("127.0.0.1", 0))
    PORT = s.getsockname()[1]

# Запускаем backend
def start_backend():
    import uvicorn
    uvicorn.run("backend.main:app", host="127.0.0.1", port=PORT)

threading.Thread(target=start_backend, daemon=True).start()
time.sleep(1)

# Открываем в режиме приложения Edge
proc = subprocess.Popen([
    "msedge", 
    f"--app=http://127.0.0.1:{PORT}",
    "--user-data-dir=%TEMP%\\KeySet"
])
proc.wait()
4. Сборка в один EXE:
pythonDownloadCopy code# keyset.spec
a = Analysis(
    ['launcher.py'],
    datas=[
        ('frontend/dist', 'frontend/dist'),  # React билд
        ('backend', 'backend'),               # Python код
        ('keyset.db', '.'),                   # База
    ],
    hiddenimports=['uvicorn', 'fastapi', 'playwright']
)

exe = EXE(a.pure, a.scripts, name='KeySet', console=False)
bashDownloadCopy codepyinstaller --onefile keyset.spec
Что получаешь:

* ✅ Один KeySet.exe (~100MB вместо 300MB Electron)
* ✅ Запуск < 1 сек (Edge уже установлен в Windows)
* ✅ React UI без изменений (100% твой дизайн)
* ✅ Никаких PyWebView/Eel

За 2-3 часа делается так:
Шаг 1: Проверь что React собирается
bashDownloadCopy codecd frontend
npm run build
# Должна появиться папка dist/
Шаг 2: Создай новый launcher.py
Скопируй код выше (20 строк) вместо твоего с PyWebView.
Шаг 3: Протестируй
bashDownloadCopy codepython launcher.py
# Должно открыться окно Edge с твоим приложением
Шаг 4: Собери EXE
bashDownloadCopy codepip install pyinstaller
pyinstaller --onefile keyset.spec
Единственная проблема GPT не упомянул:
База данных - если включить keyset.db в EXE, при каждом запуске она будет перезаписываться. Решение:
pythonDownloadCopy code# В backend/db.py добавь:
import sys, shutil
if getattr(sys, 'frozen', False):  # Если запущено из EXE
    bundled_db = Path(sys._MEIPASS) / "keyset.db"
    external_db = Path.home() / "AppData/Local/KeySet/ke