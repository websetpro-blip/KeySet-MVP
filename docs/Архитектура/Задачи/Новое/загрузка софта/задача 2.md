Что делаем прямо сейчас (минимум правок)
1) Дать бэкенду правильный путь к БД (чтобы «Аккаунты»/«Данные» наполнились)

Сейчас .exe поднялся, но API смотрит не в ту SQLite. Делаем универсально: бэкенд сам находит рабочую БД.

Файл: keyset/core/db.py (замени содержимое на это — коротко и безопасно)

from __future__ import annotations
from sqlalchemy import create_engine
from pathlib import Path
import sys

def _db_path() -> Path:
    # 1) Если запущено из exe (dist\KeySet.exe), берём БД рядом с exe: dist\keyset.db
    if getattr(sys, "frozen", False):
        p = Path(sys.executable).resolve().parent / "keyset.db"
        if p.exists():
            return p
    # 2) Если есть заполненная БД в dist\keyset.db — используем её в дев-режиме
    dist_db = Path(__file__).resolve().parents[2] / "dist" / "keyset.db"
    if dist_db.exists():
        return dist_db
    # 3) Фолбэк на проектную keyset\keyset.db (пустая/дефолт)
    proj_db = Path(__file__).resolve().parents[1] / "keyset.db"
    return proj_db

DB_PATH = _db_path()
engine = create_engine(f"sqlite:///{DB_PATH.as_posix()}", connect_args={"check_same_thread": False})


Если у тебя «живая» БД сейчас в dist\keyset.db — ничего копировать не нужно, бэкенд сам её подхватит. Если она в другом месте — скажи, подправлю порядок.

2) Раздать фронт через FastAPI (чтобы UI реально грузился из .exe)

Файл: backend/main.py (добавь в самый низ, после include_router(...))

# --- SPA раздача ---
from fastapi.staticfiles import StaticFiles
from pathlib import Path
import sys

def _spa_dir() -> Path:
    # dev: KeySet-MVP\frontend\dist
    dev_dist = Path(__file__).resolve().parents[1] / "frontend" / "dist"
    if dev_dist.exists():
        return dev_dist
    # exe: рядом с exe должна лежать папка www (см. .spec ниже)
    if getattr(sys, "frozen", False):
        return Path(sys.executable).parent / "www"
    return dev_dist

app.mount("/", StaticFiles(directory=str(_spa_dir()), html=True), name="static")


Это даёт один origin: UI (/) и API (/api/*) вместе → исчезают «Failed to fetch».

3) Убедиться, что фронт стучится на /api (без хардкода портов)

Проверь в React клиенте (где создаёшь axios/fetch), должно быть так:

// пример
export const api = axios.create({ baseURL: "/api" });


Если где-то осталось http://127.0.0.1:5173 или :8765 — убери, иначе UI в exe будет бить мимо.

4) Вложить фронт в сборку (чтобы .exe имел UI)

Файл: build/KeySet.spec — добавь frontend/dist и базовые данные в datas:

a = Analysis(
    ['launcher.py'],
    pathex=['.'],
    datas=[
        ('frontend/dist', 'www'),                              # UI внутрь exe
        ('keyset/data/regions_tree_full.json', 'keyset/data'),# GEO
        ('keyset/keyset.db', 'keyset'),                       # дефолтная БД (на случай отсутствия dist\keyset.db)
    ],
    hiddenimports=[
        'uvicorn','fastapi','jinja2',
        'playwright','playwright._impl._driver','playwright._impl._transport','playwright._impl._api_structures'
    ],
    excludes=['numpy','pandas','matplotlib'],
)


Это не ломает твою «живую» БД: по коду из п.1, при наличии dist\keyset.db будет взята именно она.

5) Профили аккаунтов и Playwright (чтоб не пропали)

Пока ничего не переносим. Если старые профили лежат, например, в keyset\.profiles\..., просто отдай их через эндпоинт.

Файл: backend/routers/accounts.py (добавь простой список профилей)

from pathlib import Path
from fastapi import APIRouter
router = APIRouter(prefix="/api/accounts", tags=["accounts"])

PROFILES_ROOT = Path(__file__).resolve().parents[2] / "keyset" / ".profiles"

@router.get("")
def list_accounts():
    if not PROFILES_ROOT.exists():
        return []
    # любой простой формат: id=имя папки, path=полный путь
    return [
        {"id": p.name, "profile_path": str(p), "status": "unknown"}
        for p in PROFILES_ROOT.iterdir() if p.is_dir()
    ]


Подключи роутер (если ещё не): в backend/main.py

from backend.routers import accounts
app.include_router(accounts.router)


Этого достаточно, чтобы вкладка «Аккаунты» что-то увидела. Формат подгоним под фронт (скажи, какие поля он ждёт — id/login/status?).

6) Данные/частотка — вытащить из БД то, что фронт ждёт

Если у тебя уже есть routers/data.py — проверь, чтобы список фраз/результатов возвращал ровно те поля, которые в таблице на фронте:

id, phrase, region_id, freq_total, freq_exact, group, updated_at (пример).

Если файла нет — добавь базовый:

# backend/routers/data.py
from fastapi import APIRouter
from sqlalchemy import text
from keyset.core.db import engine

router = APIRouter(prefix="/api/data", tags=["data"])

@router.get("/phrases")
def list_phrases(limit: int = 100):
    with engine.connect() as c:
        rows = c.execute(text("""
          SELECT id, phrase, region_id, freq_total, freq_exact, "group", updated_at
          FROM freq_results
          ORDER BY updated_at DESC
          LIMIT :limit
        """), {"limit": limit}).mappings().all()
    return {"rows": rows}

@router.get("/regions")
def list_regions():
    # если фронту нужны регионы — читаем json
    from pathlib import Path
    import json
    p = Path(__file__).resolve().parents[2] / "keyset" / "data" / "regions_tree_full.json"
    return json.loads(p.read_text(encoding="utf-8")) if p.exists() else []


И подключи:

from backend.routers import data
app.include_router(data.router)


Если при запросе /api/data/phrases получишь no such column — это не UI, а схема БД. Тогда быстро докинем миграцию/ALTER под твои реальные колонки (скажи структуру таблицы freq_results).

7) (Опционально на завтра) Кнопка «Запустить парсинг»

Минимально: фоновая задача, которая зовёт твой turbo_parser_improved.py.

# backend/routers/parsing.py
from fastapi import APIRouter, BackgroundTasks
router = APIRouter(prefix="/api/parsing", tags=["parsing"])

def run_parser(payload: dict):
    # тут импортируешь свой модуль и запускаешь
    # сохраняешь в ту же БД, которую читаем в /api/data/phrases
    from keyset.services.turbo_parser_improved import run_batch
    run_batch(payload)

@router.post("/start")
def start_parsing(payload: dict, bg: BackgroundTasks):
    bg.add_task(run_parser, payload)
    return {"status": "queued"}


Подключи:

from backend.routers import parsing
app.include_router(parsing.router)

Как проверить (быстро)

Собери фронт:
cd frontend && npm run build && cd ..

Собери exe:
py -m PyInstaller -y build\KeySet.spec

Запусти:
dist\KeySet\KeySet.exe

Проверь в окне:

http://127.0.0.1:8765/api/health → 200

http://127.0.0.1:8765/api/accounts → массив (папки профилей)

http://127.0.0.1:8765/api/data/phrases → строки из твоей БД

вкладка «Аккаунты»/«Данные» — показывает содержимое

Если «Аккаунты/Данные» пустые:

Скажи, где твоя насыщенная БД (путь). Подкручу приоритет в db.py.

Покажи Network (статус-коды /api/*) — сразу пойму, поле/таблица/эндпоинт.

Ответ на твой вопрос «начинать с Этапа 1?»

Да. Этап 1 — синхронизация БД я выше уже сделал «правильно»: не копируем руками, а даём бэкенду подобрать правильную БД автоматически (dist → приоритет). Это моментально оживит «Аккаунты/Данные». Дальше дёрнем парсер через простой эндпоинт.