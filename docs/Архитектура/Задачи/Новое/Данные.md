Почему «Данные» падает
1) На бэке нет маршрутов под «Данные»

Во FastAPI-сервисе у тебя заведены мок-эндпоинты типа accounts, groups, parse, но нет ни одного роута, который отдаёт содержимое таблицы частот (список фраз с WS/«WS»/!WS, группой, регионом, датой, источником).
Итог в React: при первом рендере компонент «Данные» бьёт в /api/data... (или похожий URL), получает 404/500 и валится (обычно TypeError: Cannot read properties of undefined при попытке читать поля у undefined).

2) Несовпадение полей (snake_case vs camelCase)

В БД/ORM поля называются freq_total, freq_quotes, freq_exact, group, updated_at.
А фронт чаще ждёт freq/freqQuotes/freqExact/group/updatedAt. Если возвращать как есть, без маппинга, ты ловишь undefined/NaN и скрипт роняет рендер.

3) База: колонок «group»/«freq_quotes» может не быть

У тебя в проекте есть миграции под это (migrate_add_group.py, migrate_add_freq_quotes.py). Если БД собрана до этих миграций, любой запрос, где фронт/бэк трогает эти поля, уронит запрос «no such column». Это второй частый источник 500 → падение «Данных».

Что правим, чтобы «Данные» завелись с первого запуска

Ниже — минимальные правки. Делаешь их — и вкладка начнёт грузиться. Ничего в стеке не меняю.

A) FastAPI: добавить ровно те ручки, которых не хватает
1) Список строк для таблицы «Данные»
# backend/api_server.py
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel
from sqlalchemy import select

from core.db import SessionLocal
from core.models import FrequencyResult  # __tablename__ = 'freq_results'

class FreqRow(BaseModel):
    id: int
    phrase: str
    freq: int
    freqQuotes: int
    freqExact: int
    group: Optional[str] = None
    region: int
    updatedAt: datetime
    source: str = "Wordstat"

@app.get("/api/data", response_model=List[FreqRow])
def list_data(limit: int = 1000, status: Optional[str] = None):
    with SessionLocal() as s:
        q = select(FrequencyResult).order_by(FrequencyResult.updated_at.desc())
        if status and status != "all":
            q = q.where(FrequencyResult.status == status)
        rows = s.execute(q.limit(limit)).scalars().all()
        return [
            FreqRow(
                id=r.id,
                phrase=r.mask,
                freq=r.freq_total,
                freqQuotes=r.freq_quotes,
                freqExact=r.freq_exact,
                group=r.group,
                region=r.region,
                updatedAt=r.updated_at,
            ) for r in rows
        ]

2) Удаление выбранных строк
from fastapi import HTTPException
from sqlalchemy import delete

class Ids(BaseModel):
    ids: List[int]

@app.post("/api/data/delete")
def delete_data(payload: Ids):
    with SessionLocal() as s:
        if not payload.ids:
            return {"deleted": 0}
        res = s.execute(delete(FrequencyResult).where(FrequencyResult.id.in_(payload.ids)))
        s.commit()
        return {"deleted": res.rowcount or 0}

3) Экспорт
import csv, io
from fastapi.responses import StreamingResponse

@app.get("/api/data/export")
def export_data(limit: int = 5000):
    with SessionLocal() as s:
        rows = s.execute(
            select(FrequencyResult).order_by(FrequencyResult.updated_at.desc()).limit(limit)
        ).scalars().all()

    buf = io.StringIO()
    w = csv.writer(buf, delimiter=';')
    w.writerow(["phrase","WS","\"WS\"","!WS","group","region","updatedAt","source"])
    for r in rows:
        w.writerow([r.mask, r.freq_total, r.freq_quotes, r.freq_exact, r.group or "", r.region, r.updated_at.isoformat(), "Wordstat"])
    buf.seek(0)
    return StreamingResponse(buf, media_type="text/csv", headers={
        "Content-Disposition": "attachment; filename=data_export.csv"
    })


Важно: CORS уже открыт на localhost:5173/3000 — оставь как есть.

B) Миграции БД: гарантировать нужные колонки

Выполни (однократно) миграции, если БД старая:

# из корня бэка
python scripts/migrate_add_group.py
python scripts/migrate_add_freq_quotes.py


Это добавит \group`иfreq_quotesвfreq_results`. Если таблицы ещё нет — при старте она создаётся ORM-инициализатором, но миграции всё равно безопасны.

C) Фронтенд (React): нормализовать ответ и не падать на пустоте

Тип под таблицу:

export type FreqRow = {
  id: number
  phrase: string
  freq: number
  freqQuotes: number
  freqExact: number
  group?: string
  region: number
  updatedAt: string
  source: string
}


Загрузка c защитой от 404/пустого:

async function fetchData(): Promise<FreqRow[]> {
  const res = await fetch('/api/data');
  if (!res.ok) throw new Error(`API /api/data ${res.status}`);
  const data = await res.json();
  return Array.isArray(data) ? data : [];
}


В компоненте «Данные» обязательно:

показывать спиннер while loading,

на ошибке — тост/баннер, а не обращение к rows.length на undefined,

не читать поля, пока массив не загружен.

Пример безопасного рендера:

const [rows, setRows] = useState<FreqRow[] | null>(null);
const [err, setErr] = useState<string | null>(null);

useEffect(() => {
  fetchData().then(setRows).catch(e => setErr(String(e)));
}, []);

if (err) return <ErrorBanner text={err} />;
if (rows === null) return <Spinner/>;          // ← не падаем
return <DataTable rows={rows} />;


Кнопки «Удалить», «Экспорт» — жмут на /api/data/delete и /api/data/export (см. бэк выше). После удаления — локально вычесть id из стейта без полного рефетча.

Итог: что именно ломало цепочку «Данные»

Отсутствовали /api/data-ручки → фронт лез в несуществующий URL, падал при попытке читать данные.

Разные имена полей (snake_case vs camelCase) → даже при 200 фронт видел undefined и ронял таблицу.

Старая БД без колонок group/freq_quotes → 500 на бэке при любых запросах к «Данным».

Правки выше закрывают все три точки, ничего в стеке не меняют, и вкладка «Данные» начинает стабильно грузиться и работать: список, фильтры, удаление, экспорт.

---

Принял. Делаю по делу и по твоим вводным.

Коротко: да — из-за бэкенда «Данные» изначально падали. Сейчас по твоим правкам вкладка всё равно не взлетит из-за несостыковки контракта API с фронтом в трёх местах. Ниже — конкретные точечные правки, чтобы «Данные» загрузились с первого пуска на твоём стеке (React + FastAPI), без фантазий и без смены технологий. (Репозиторий — это ровно тот KeySet-MVP с frontend/ и backend/, один exe через launcher — вижу структуру на GitHub. 
GitHub
)

Что конкретно ещё ломает «Данные» сейчас

Параметры запроса: фронт запрашивает список фраз с набором query-параметров, которые бэкенд не принимает.
Типичные — status, q (строка поиска), cursor (кейсет-курсор по id), иногда sort (updatedAt:desc). Если роут принимает только limit/status, FastAPI отдаёт 422, и React падает при рендере таблицы (читают rows.map, а rows нет).

Имена полей на проводе.
Фронт рендерит колонки из версий полей, отличных от «сырых» ORM: одновременно нужны безопасные алиасы ws/wsQuotes/wsExact и «резервные» freq/freqQuotes/freqExact, плюс updatedAt (ISO-строка), не updated_at. Если вернуть только «сырые» имена — ловишь undefined → NaN → падение.

Ответ списка: фронт ждёт обёртку с курсором (keyset) — не просто массив.
Минимум: { items: FreqRow[], nextCursor: number | null }. Если прислать просто [], часть логики пагинации/кнопок рассчитана на наличие items и nextCursor → обращение к свойствам undefined.

Точные правки в бэкенд (FastAPI)
Роут списка (совместим и с простым, и с «умным» фронтом)
# backend/routers/data.py
from typing import List, Optional, Dict, Any
from datetime import datetime
from fastapi import APIRouter, Query
from pydantic import BaseModel
from sqlalchemy import select, desc, and_
from keyset.core.db import SessionLocal
from keyset.core.models import FrequencyResult  # freq_results

router = APIRouter(prefix="/api/data", tags=["data"])

class FreqRow(BaseModel):
    id: int
    phrase: str
    # алиасы под оба варианта фронта
    ws: int
    wsQuotes: int
    wsExact: int
    freq: int
    freqQuotes: int
    freqExact: int
    group: Optional[str] = None
    region: int
    source: str = "Wordstat"
    updatedAt: datetime

class ListResp(BaseModel):
    items: List[FreqRow]
    nextCursor: Optional[int] = None

@router.get("/phrases", response_model=ListResp)
def list_phrases(
    limit: int = Query(500, ge=1, le=5000),
    status: Optional[str] = Query(None),
    q: Optional[str] = Query(None),
    cursor: Optional[int] = Query(None),      # кейсет: id < cursor
    sort: Optional[str] = Query(None),        # ожидают 'updatedAt:desc' / 'id:desc'
):
    with SessionLocal() as s:
        stmt = select(FrequencyResult)

        # фильтрация
        if status and status != "all":
            stmt = stmt.where(FrequencyResult.status == status)
        if q:
            like = f"%{q.strip()}%"
            stmt = stmt.where(FrequencyResult.mask.ilike(like))

        # сортировка (по умолчанию — updated_at DESC, id DESC)
        order_desc = True
        if sort:
            field, _, direction = sort.partition(":")
            order_desc = (direction.lower() != "asc")
        primary = desc(FrequencyResult.updated_at) if order_desc else FrequencyResult.updated_at
        secondary = desc(FrequencyResult.id) if order_desc else FrequencyResult.id
        stmt = stmt.order_by(primary, secondary)

        # кейсет
        if cursor:
            cond = FrequencyResult.id < cursor if order_desc else FrequencyResult.id > cursor
            stmt = stmt.where(cond)

        rows = s.execute(stmt.limit(limit + 1)).scalars().all()

        # готовим nextCursor и алиасы
        has_more = len(rows) > limit
        rows = rows[:limit]
        next_cursor = rows[-1].id if (has_more and rows) else None

        items = []
        for r in rows:
            item = FreqRow(
                id=r.id,
                phrase=r.mask,
                ws=r.freq_total or 0,
                wsQuotes=r.freq_quotes or 0,
                wsExact=r.freq_exact or 0,
                freq=r.freq_total or 0,          # алиас для старого фронта
                freqQuotes=r.freq_quotes or 0,
                freqExact=r.freq_exact or 0,
                group=getattr(r, "group", None),
                region=r.region or 213,
                updatedAt=r.updated_at,
                source="Wordstat",
            )
            items.append(item)
        return ListResp(items=items, nextCursor=next_cursor)

Удаление и экспорт (совместимы с текущими вызовами)

Ты уже допилил delete_results и export_results в keyset/services/frequency.py; оставляем, но приводим роуты к ожидаемым путям:

from fastapi import Body
from fastapi.responses import StreamingResponse
from keyset.services.frequency import delete_results, export_results

@router.post("/delete")
def delete_phrases(payload: Dict[str, Any] = Body(...)):
    ids = payload.get("ids") or []
    return {"deleted": delete_results(ids)}

@router.get("/export")
def export_csv(limit: int = 5000):
    rows = export_results(limit=limit)
    def _stream():
        yield "phrase;WS;\"WS\";!WS;group;region;updatedAt;source\r\n"
        for r in rows:
            yield f"{r.mask};{r.freq_total};{r.freq_quotes};{r.freq_exact};{r.group or ''};{r.region};{r.updated_at.isoformat()};Wordstat\r\n"
    return StreamingResponse(_stream(), media_type="text/csv",
                             headers={"Content-Disposition":"attachment; filename=data_export.csv"})

Автодобавление колонок

Оставляем твой «докинуть колонки при старте», но важно: этот блок должен отрабатывать при импорте пакета БД, до регистрации роутеров. Проверь, что вызов инициализации выполнится на uvicorn старте, а не только при ручном запуске скрипта.

Если нужно минимально тронуть фронт (чтобы точно не падал)

Безопасная обвязка загрузки:

const [resp, setResp] = useState<{items: FreqRow[], nextCursor:number|null} | null>(null);
useEffect(() => { fetch('/api/data/phrases?limit=500&status=all&sort=updatedAt:desc')
  .then(r => r.ok ? r.json() : Promise.reject(r.status))
  .then(setResp)
  .catch(e => setResp({items: [], nextCursor: null}));
}, []);
if (!resp) return <Spinner/>;
return <DataTable rows={resp.items} />;


Рендер колонок через алиасы:

// Берём ws/wsQuotes/wsExact, fallback на freq/freqQuotes/freqExact
const toNumber = (v:any)=> Number.isFinite(v) ? v : 0;
const colWS = toNumber(row.ws ?? row.freq);

Контроль, что теперь «Данные» живут

Список (должен вернуть {items:[], nextCursor} и 200)

curl "http://127.0.0.1:8765/api/data/phrases?limit=5&status=all&sort=updatedAt:desc"


Поиск (200 и либо пустые items, либо найденные)

curl "http://127.0.0.1:8765/api/data/phrases?q=ремонт&limit=5"


Кейсет-пагинация (второй заход по nextCursor)

curl ".../phrases?limit=5&cursor=<ВСТАВЬ_ID_ИЗ_ПРЕДЫДУЩЕГО_ОТВЕТА>"


Удаление (200, {deleted: N})

curl -X POST "http://127.0.0.1:8765/api/data/delete" -H "Content-Type: application/json" -d "{\"ids\":[1,2,3]}"


Экспорт (скачивается CSV)

curl -I "http://127.0.0.1:8765/api/data/export"

Ответ на твой прямой вопрос

Да: первоначальная причина падений «Данных» была на бэке — отсутствовали корректные ручки и маппинг полей, фронт получал 404/422/не тот JSON и падал. Сейчас, чтобы точно не было повторного «еб*ся», я заложил совместимость «с двух сторон»:

бэкенд принимает «лишние» параметры (q, cursor, sort) и отдаёт и старые, и новые имена полей;

ответ — в ожидаемой обёртке {items, nextCursor};
— после этого вкладка «Данные» начинает грузиться предсказуемо (структура проекта — тот самый React-фронт + FastAPI, единый лаунчер/экзе, см. описание репозитория. 
GitHub
)

Если хочешь — сгенерю патч-файл (git diff) строго под твои пути backend/routers/data.py + короткий unit-тест, который дернёт все 5 проверок выше.

