## 05. Цепочка «Данные → Гео → Частотка»

> Памятка для всех, кто будет подключать остальные модули: здесь собран полный цикл восстановления вкладки «Данные» в KeySet-MVP (ноябрь 2025). Следуем ровно этим шагам для других разделов — только перенос и интеграция готовых сервисов, никаких переписываний.

### 1. Исходное состояние (до 09.11.2025)
- React-вкладка уже портирована из «ГОТОВЫХ МОДУЛЕЙ», но:
  - `/api/data/phrases` отдавал `[]` или падал 404, потому что бэкенд не имел маршрутов, возвращающих те же поля, что ждёт UI.
  - `frequency.py` не возвращал `id`, `freq_exact`, `freq_quotes` и не умел удалять/экспортировать строки.
  - `freq_results` в SQLite не содержала колонок `freq_quotes`, `freq_exact`, `group` — старые базы ломали даже SELECT.
  - Zustand-стор и модалки опирались на localStorage: регидратация кидала `addLog()` прямо во время `set()`, поэтому React выдавал `Minified error #185`.
  - WordstatModal рендерился всегда и сразу дёргал `loadInitialData()` → бесконечный цикл `setState`.

**Итог:** вкладка «Данные» падала сразу после открытия, цепочка гео/частотки была обрублена на уровне API.

### 2. Backend: выравнивание с legacy-сервисами
1. **`keyset/core/db.py`** — при старте докидываем недостающие колонки в `freq_results`, чтобы старые SQLite-файлы не роняли ORM.
2. **`keyset/services/frequency.py`**:
   - `list_results()` теперь возвращает `id`, `mask`, `freq_total`, `freq_quotes`, `freq_exact`, `updated_at`, `group`.
   - Добавлены `delete_results(ids)`, `clear_results()`, `export_results()` — всё через существующие SQL-helpers, без переписывания логики.
3. **`backend/routers/data.py`**:
   - `GET /api/data/phrases` → адаптер над `frequency.list_results`, поддерживает `limit/offset/search/status/q/cursor/sort` и возвращает `{ items, nextCursor }`.
   - `POST /api/data/{enqueue|delete|clear|group}` → тонкие прокладки к `frequency_service`.
   - `GET /api/data/export` → стрим CSV (8 колонок + ISO `updatedAt`), чтобы фронт не генерировал файл сам.

### 3. Frontend: безопасный стор и клиент
1. **API-клиент (`frontend/src/modules/data/api/data.ts`)**
   - DTO расширены полями `wsQuotes/wsExact/freq*`, запросы умеют `cursor`, `sort`, `q`.
   - `fetchPhrases` парсит структуру `{ items, nextCursor }`.
2. **Стор (`frontend/src/modules/data/store/useStore.ts`)**
   - Добавлен `phrasesCursor`, мапперы `pickNumber` для `ws/qws/bws`.
   - `loadInitialData()` ждёт `items`, сбрасывает selected/pinned sets и сохраняет `phrasesCursor`.
   - Регидратация: `addLog` вызывается через `setTimeout(..., 0)` — нет рекурсивных setState.
3. **UI/модалки**
   - WordstatModal и остальные окна рендерятся по условию `isOpen`, используют «safe» массивы/Set (guard от битых localStorage).
   - ErrorBoundary отправляет падения в `POST /api/debug/react-error`, чтобы новые проблемы видно было в `backend/react_errors.log`.

### 4. Диагностика и тесты
1. `npm run build` (Vite) + `python -m py_compile launcher.py` — проверка синтаксиса.
2. `python launcher.py` → ручной заход на вкладку «Данные», проверка:
   - таблица показывает строки из SQLite (`ws/qws/bws` совпадают),
   - журнал активности оживает,
   - React #185 не появляется (react_errors.log пустой после запуска).
3. Скрин 10.11.2025 09:48, сохранённый заказчиком, фиксирует успешный запуск.

### 5. Что делать при подключении других модулей
1. **Не писать логику заново.** Только оборачиваем функции из `keyset/services/*` и `keyset/core/db.py`.
2. **Всегда держать API и фронт синхронными:** если бэкенд возвращает `{ items, nextCursor }`, стор обязан работать с этой структурой.
3. **Перед пушем:** `npm run build`, `python launcher.py`, обновление `ГОТОВЫЕ_МОДУЛИ_план.md`.
4. **Документировать** любые изменения в `ARCHITECTURE/*.md`, чтобы следующий модуль не повторял те же разобранные грабли.

Теперь вкладка «Данные» служит эталоном переноса: backend → адаптеры → стор → UI → проверка. По этой схеме подключаем Маски, Аккаунты и остальные модули.
