// lib/negative-sets-builder.ts
// Система автоматического формирования минус-слов с отраслевыми профилями

import { UNode } from './tree_ops';

export type IndustryType = 'ecommerce' | 'services' | 'medical' | 'auto';
export type NegativeType = 'global' | 'thematic' | 'contextual' | 'competitor';

export interface NegativeWordSet {
  type: NegativeType;
  industry: IndustryType;
  words: string[];
  description: string;
  confidence: number; // Уверенность в релевантности (0-1)
  autoGenerated: boolean;
  source?: string; // Источник (profile, xmind, manual)
}

export interface IndustryProfile {
  industry: IndustryType;
  name: string;
  description: string;
  global: Record<string, string[]>;
  thematic: Record<string, string[]>;
  contexts: Record<string, string[]>;
  auto_detection: {
    keywords: string[];
    brands?: string[];
    categories?: string[];
    service_types?: string[];
    specialties?: string[];
    locations?: string[];
  };
}

export interface XMindAnalysisResult {
  detectedIndustry: IndustryType | null;
  confidence: number;
  keywords: string[];
  brands: string[];
  categories: string[];
  relevantBranches: string[];
  reasoning: string;
}

export interface NegativeWordsResult {
  global: NegativeWordSet[];
  thematic: NegativeWordSet[];
  contextual: NegativeWordSet[];
  totalWords: number;
  analysis: XMindAnalysisResult;
  recommendations: string[];
}

/**
 * NegativeSetsBuilder - система автоматического формирования минус-слов
 */
export class NegativeSetsBuilder {
  private profiles: Map<IndustryType, IndustryProfile> = new Map();
  private customWords: Set<string> = new Set();

  constructor() {
    this.loadIndustryProfiles();
  }

  /**
   * Загрузка отраслевых профилей из JSON файлов
   */
  private async loadIndustryProfiles(): Promise<void> {
    try {
      // В реальном приложении здесь был бы fetch() для JSON файлов
      // Пока используем встроенные профили для демонстрации
      const ecommerceProfile = await this.loadProfile('ecommerce');
      const servicesProfile = await this.loadProfile('services');
      const medicalProfile = await this.loadProfile('medical');

      this.profiles.set('ecommerce', ecommerceProfile);
      this.profiles.set('services', servicesProfile);
      this.profiles.set('medical', medicalProfile);
    } catch (error) {
      console.error('Ошибка загрузки профилей:', error);
    }
  }

  /**
   * Загрузка профиля (заглушка для демонстрации)
   */
  private async loadProfile(industry: string): Promise<IndustryProfile> {
    // В реальном приложении здесь был бы fetch() соответствующего JSON файла
    const profiles = {
      'ecommerce': {
        industry: 'ecommerce' as const,
        name: 'E-commerce',
        description: 'Интернет-магазины и онлайн-торговля',
        global: {
          'category': ['бесплатно', 'скачать', 'торрент', 'ремонт', 'инструкция'],
          'commercial': ['продать', 'бу', 'б/у', 'подержанный'],
          'competitors': ['aliexpress', 'wb', 'ozon', 'avito'],
          'irrelevant': ['магазин закрылся', 'нет в наличии']
        },
        thematic: {
          'electronics': ['лампочка', 'батарейка', 'зарядка', 'кабель'],
          'clothing': ['выкройка', 'лекало', 'шитье', 'вязание'],
          'home': ['инструмент', 'дрель', 'шуруповерт', 'молоток']
        },
        contexts: {
          'price_queries': ['цена', 'стоимость', 'дешево', 'акция'],
          'comparison': ['сравнить', 'лучше', 'отзыв', 'обзор'],
          'location': ['доставка', 'курьер', 'самовывоз']
        },
        auto_detection: {
          keywords: ['магазин', 'интернет-магазин', 'купить', 'каталог'],
          brands: ['samsung', 'apple', 'xiaomi', 'huawei'],
          categories: ['электроника', 'одежда', 'дом', 'красота']
        }
      },
      'services': {
        industry: 'services' as const,
        name: 'Услуги',
        description: 'Компании, предоставляющие услуги',
        global: {
          'category': ['бесплатно', 'дома', 'своими руками', 'инструкция'],
          'commercial': ['продать', 'бу', 'аренда инструментов'],
          'competitors': ['olx', 'avito', 'youdo'],
          'irrelevant': ['удаленно', 'онлайн', 'бесплатная консультация']
        },
        thematic: {
          'construction': ['стройматериалы', 'кирпич', 'цемент'],
          'repair': ['запчасти', 'замена', 'сборка'],
          'cleaning': ['химия', 'моющее средство', 'порошок']
        },
        contexts: {
          'urgency': ['срочно', 'недорого', 'быстро'],
          'comparison': ['сравнить цены', 'где дешевле', 'отзывы'],
          'location': ['выезд', 'на дому', 'в офисе']
        },
        auto_detection: {
          keywords: ['услуги', 'ремонт', 'строительство', 'уборка'],
          service_types: ['ремонт', 'строительство', 'уборка', 'доставка'],
          locations: ['выезд на дом', 'офис', 'квартира', 'дом']
        }
      },
      'medical': {
        industry: 'medical' as const,
        name: 'Медицина',
        description: 'Медицинские услуги и товары',
        global: {
          'category': ['рецепт', 'диагноз', 'лечение', 'операция'],
          'commercial': ['продать', 'бу', 'арендованный'],
          'competitors': ['госполиклиника', 'больница', 'омс'],
          'irrelevant': ['самостоятельно', 'домашних условиях']
        },
        thematic: {
          'medications': ['антибиотик', 'рецепт', 'дозировка'],
          'equipment': ['тонометр', 'глюкометр', 'небулайзер'],
          'diagnostics': ['узи', 'кт', 'мрт', 'рентген']
        },
        contexts: {
          'urgency': ['срочно', 'экстренно', 'скорая помощь'],
          'quality': ['опытный врач', 'квалифицированный специалист'],
          'accessibility': ['запись онлайн', 'электронная запись', 'талон']
        },
        auto_detection: {
          keywords: ['врач', 'клиника', 'больница', 'медицинский'],
          specialties: ['кардиология', 'неврология', 'хирургия'],
          locations: ['больница', 'поликлиника', 'клиника']
        }
      }
    };

    return profiles[industry as keyof typeof profiles];
  }

  /**
   * Анализ XMind карты для определения отрасли
   */
  analyzeXMind(xmindData: UNode | null): XMindAnalysisResult {
    if (!xmindData) {
      return {
        detectedIndustry: null,
        confidence: 0,
        keywords: [],
        brands: [],
        categories: [],
        relevantBranches: [],
        reasoning: 'XMind данные отсутствуют'
      };
    }

    const allText = this.extractAllText(xmindData);
    const keywords = this.extractKeywords(allText);
    const brands = this.extractBrands(allText);
    const categories = this.extractCategories(allText);
    const relevantBranches = this.findRelevantBranches(xmindData, keywords);

    // Определяем отрасль на основе ключевых слов
    const industryScores = this.calculateIndustryScores(keywords, brands, categories);
    const detectedIndustry = industryScores.length > 0 ? industryScores[0].industry : null;
    const confidence = detectedIndustry ? industryScores[0].score : 0;

    const reasoning = detectedIndustry 
      ? `Отрасль определена на основе: ${relevantBranches.join(', ')}`
      : 'Отрасль не определена - недостаточно данных';

    return {
      detectedIndustry,
      confidence,
      keywords,
      brands,
      categories,
      relevantBranches,
      reasoning
    };
  }

  /**
   * Извлечение всего текста из XMind структуры
   */
  private extractAllText(node: UNode): string[] {
    const texts: string[] = [node.title.toLowerCase()];
    (node.labels || []).forEach(label => texts.push(label.toLowerCase()));
    
    if (node.children) {
      node.children.forEach(child => {
        texts.push(...this.extractAllText(child));
      });
    }
    
    return texts;
  }

  /**
   * Извлечение ключевых слов из текста
   */
  private extractKeywords(texts: string[]): string[] {
    const keywordPattern = /\b(магазин|интернет-магазин|купить|заказать|услуги|ремонт|строительство|врач|клиника|больница|медицинский|здоровье)\b/g;
    const keywords: Set<string> = new Set();
    
    texts.forEach(text => {
      const matches = text.match(keywordPattern);
      if (matches) {
        matches.forEach(match => keywords.add(match));
      }
    });
    
    return Array.from(keywords);
  }

  /**
   * Извлечение брендов из текста
   */
  private extractBrands(texts: string[]): string[] {
    const brands = ['samsung', 'apple', 'xiaomi', 'huawei', 'oneplus', 'asus', 'acer', 'lenovo'];
    const foundBrands: Set<string> = new Set();
    
    texts.forEach(text => {
      brands.forEach(brand => {
        if (text.includes(brand)) {
          foundBrands.add(brand);
        }
      });
    });
    
    return Array.from(foundBrands);
  }

  /**
   * Извлечение категорий из текста
   */
  private extractCategories(texts: string[]): string[] {
    const categories = ['электроника', 'одежда', 'дом', 'красота', 'спорт', 'авто', 'детские товары', 'одежда', 'обувь'];
    const foundCategories: Set<string> = new Set();
    
    texts.forEach(text => {
      categories.forEach(category => {
        if (text.includes(category)) {
          foundCategories.add(category);
        }
      });
    });
    
    return Array.from(foundCategories);
  }

  /**
   * Поиск релевантных веток в XMind
   */
  private findRelevantBranches(node: UNode, keywords: string[]): string[] {
    const branches: string[] = [];
    
    const checkNode = (n: UNode) => {
      const nodeText = n.title.toLowerCase();
      if (keywords.some(keyword => nodeText.includes(keyword))) {
        branches.push(n.title);
      }
      n.children?.forEach(checkNode);
    };
    
    checkNode(node);
    return branches;
  }

  /**
   * Расчет оценок отраслей
   */
  private calculateIndustryScores(keywords: string[], brands: string[], categories: string[]): Array<{industry: IndustryType, score: number}> {
    const scores: Array<{industry: IndustryType, score: number}> = [];
    
    for (const [industry, profile] of this.profiles) {
      let score = 0;
      
      // Подсчет по ключевым словам
      keywords.forEach(keyword => {
        if (profile.auto_detection.keywords.some(autoKeyword => 
          keyword.includes(autoKeyword) || autoKeyword.includes(keyword))) {
          score += 1;
        }
      });
      
      // Подсчет по брендам
      brands.forEach(brand => {
        if (profile.auto_detection.brands?.some(autoBrand => brand.includes(autoBrand))) {
          score += 0.5;
        }
      });
      
      // Подсчет по категориям
      categories.forEach(category => {
        if (profile.auto_detection.categories?.some(autoCategory => 
          category.includes(autoCategory) || autoCategory.includes(category))) {
          score += 0.3;
        }
      });
      
      if (score > 0) {
        scores.push({ industry, score });
      }
    }
    
    return scores.sort((a, b) => b.score - a.score);
  }

  /**
   * Формирование минус-слов на основе анализа
   */
  generateNegativeWords(xmindData: UNode | null, customWords: string[] = []): NegativeWordsResult {
    const analysis = this.analyzeXMind(xmindData);
    const negativeSets: NegativeWordsResult = {
      global: [],
      thematic: [],
      contextual: [],
      totalWords: 0,
      analysis,
      recommendations: []
    };

    // Если отрасль определена, используем соответствующий профиль
    if (analysis.detectedIndustry) {
      const profile = this.profiles.get(analysis.detectedIndustry);
      if (profile) {
        negativeSets.global = this.buildGlobalNegatives(profile, analysis);
        negativeSets.thematic = this.buildThematicNegatives(profile, analysis);
        negativeSets.contextual = this.buildContextualNegatives(profile, analysis);
      }
    }

    // Добавляем пользовательские минус-слова
    this.addCustomNegatives(negativeSets, customWords);

    // Подсчитываем общее количество
    negativeSets.totalWords = [
      ...negativeSets.global,
      ...negativeSets.thematic,
      ...negativeSets.contextual
    ].reduce((total, set) => total + set.words.length, 0);

    // Формируем рекомендации
    negativeSets.recommendations = this.generateRecommendations(analysis, negativeSets);

    return negativeSets;
  }

  /**
   * Построение глобальных минус-слов
   */
  private buildGlobalNegatives(profile: IndustryProfile, analysis: XMindAnalysisResult): NegativeWordSet[] {
    const sets: NegativeWordSet[] = [];
    
    for (const [category, words] of Object.entries(profile.global)) {
      sets.push({
        type: 'global',
        industry: profile.industry,
        words: this.normalizeWords(words),
        description: `Глобальные минус-слова для категории: ${category}`,
        confidence: 0.9,
        autoGenerated: true,
        source: 'profile'
      });
    }
    
    return sets;
  }

  /**
   * Построение тематических минус-слов
   */
  private buildThematicNegatives(profile: IndustryProfile, analysis: XMindAnalysisResult): NegativeWordSet[] {
    const sets: NegativeWordSet[] = [];
    
    for (const [theme, words] of Object.entries(profile.thematic)) {
      // Проверяем релевантность темы
      const relevance = this.calculateThemeRelevance(theme, analysis);
      
      if (relevance > 0.3) {
        sets.push({
          type: 'thematic',
          industry: profile.industry,
          words: this.normalizeWords(words),
          description: `Тематические минус-слова для: ${theme}`,
          confidence: relevance,
          autoGenerated: true,
          source: 'profile'
        });
      }
    }
    
    return sets;
  }

  /**
   * Построение контекстуальных минус-слов
   */
  private buildContextualNegatives(profile: IndustryProfile, analysis: XMindAnalysisResult): NegativeWordSet[] {
    const sets: NegativeWordSet[] = [];
    
    for (const [context, words] of Object.entries(profile.contexts)) {
      sets.push({
        type: 'contextual',
        industry: profile.industry,
        words: this.normalizeWords(words),
        description: `Контекстуальные минус-слова для: ${context}`,
        confidence: 0.7,
        autoGenerated: true,
        source: 'profile'
      });
    }
    
    return sets;
  }

  /**
   * Добавление пользовательских минус-слов
   */
  private addCustomNegatives(negativeSets: NegativeWordsResult, customWords: string[]): void {
    if (customWords.length === 0) return;
    
    const normalizedCustomWords = this.normalizeWords(customWords);
    
    negativeSets.global.push({
      type: 'global',
      industry: 'ecommerce', // По умолчанию
      words: normalizedCustomWords,
      description: 'Пользовательские минус-слова',
      confidence: 1.0,
      autoGenerated: false,
      source: 'manual'
    });
  }

  /**
   * Расчет релевантности темы
   */
  private calculateThemeRelevance(theme: string, analysis: XMindAnalysisResult): number {
    const themeKeywords = {
      'electronics': ['электроника', 'техника', 'устройство', 'прибор'],
      'clothing': ['одежда', 'мода', 'стиль', 'текстиль'],
      'home': ['дом', 'квартира', 'интерьер', 'мебель'],
      'construction': ['строительство', 'ремонт', 'отделка'],
      'repair': ['ремонт', 'замена', 'сборка'],
      'medications': ['лекарство', 'препарат', 'таблетки'],
      'equipment': ['оборудование', 'аппарат', 'прибор']
    };

    const keywords = themeKeywords[theme as keyof typeof themeKeywords] || [];
    const matches = analysis.keywords.filter(keyword => 
      keywords.some(kw => keyword.includes(kw) || kw.includes(keyword))
    ).length;

    return Math.min(matches / keywords.length, 1);
  }

  /**
   * Нормализация слов
   */
  private normalizeWords(words: string[]): string[] {
    return words
      .map(word => word.trim().toLowerCase())
      .filter(word => word.length > 0)
      .filter((word, index, arr) => arr.indexOf(word) === index); // Убираем дубликаты
  }

  /**
   * Генерация рекомендаций
   */
  private generateRecommendations(analysis: XMindAnalysisResult, negativeSets: NegativeWordsResult): string[] {
    const recommendations: string[] = [];

    if (analysis.detectedIndustry) {
      recommendations.push(`Определена отрасль: ${this.profiles.get(analysis.detectedIndustry)?.name}`);
    } else {
      recommendations.push('Отрасль не определена - используются общие минус-слова');
    }

    if (analysis.confidence < 0.5) {
      recommendations.push('Низкая уверенность в определении отрасли - рекомендуется ручная настройка');
    }

    if (negativeSets.totalWords < 10) {
      recommendations.push('Мало минус-слов - возможно, стоит добавить специфичные для бизнеса');
    }

    recommendations.push(`Всего сгенерировано минус-слов: ${negativeSets.totalWords}`);

    return recommendations;
  }

  /**
   * Экспорт минус-слов в различных форматах
   */
  exportNegativeWords(negativeSets: NegativeWordsResult, format: 'csv' | 'txt' = 'csv'): string {
    const allWords = [
      ...negativeSets.global,
      ...negativeSets.thematic,
      ...negativeSets.contextual
    ].flatMap(set => set.words);

    const uniqueWords = Array.from(new Set(allWords));

    if (format === 'csv') {
      return `negative_word\n${uniqueWords.map(word => `"${word.replace(/"/g, '""')}"`).join('\n')}`;
    } else {
      return uniqueWords.join('\n');
    }
  }
}

// Экспорт утилит
export const NegativeSetsUtils = {
  /**
   * Проверка качества минус-слов
   */
  validateNegativeWords(words: string[]): { valid: boolean; errors: string[] } {
    const errors: string[] = [];

    // Проверка на слишком короткие слова
    const shortWords = words.filter(word => word.length < 2);
    if (shortWords.length > 0) {
      errors.push(`Слишком короткие слова: ${shortWords.slice(0, 5).join(', ')}${shortWords.length > 5 ? '...' : ''}`);
    }

    // Проверка на дубликаты
    const uniqueWords = new Set(words.map(w => w.toLowerCase()));
    if (uniqueWords.size < words.length) {
      errors.push(`Обнаружены дубликаты минус-слов`);
    }

    // Проверка на русские символы
    const nonRussianWords = words.filter(word => !/[а-яё]/i.test(word));
    if (nonRussianWords.length > words.length * 0.3) {
      errors.push('Много слов без русских символов - возможно, ошибка ввод');
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }
};
