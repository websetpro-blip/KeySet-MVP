import React from 'react';
import {
  useReactTable,
  getCoreRowModel,
  getSortedRowModel,
  flexRender,
  createColumnHelper,
  SortingState,
} from '@tanstack/react-table';
import { ArrowUp, ArrowDown, CheckCircle2, Pin, Lock } from 'lucide-react';
import { Checkbox } from '../ui/Checkbox';
import { useStore } from '../../store/useStore';
import type { Phrase } from '../../types';
import { cn } from '../../lib/utils';

const columnHelper = createColumnHelper<Phrase>();

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–≥–æ –º–µ–Ω—é
const ContextMenu: React.FC<{
  x: number;
  y: number;
  phrase: Phrase;
  onClose: () => void;
  onShowHistory?: (phraseId: string) => void;
}> = ({ x, y, phrase, onClose, onShowHistory }) => {
  const { 
    groups, 
    editPhrase, 
    markRowColor, 
    toggleRowLock, 
    deletePhrases, 
    movePhrasesToGroup,
    addStopword,
    addLog 
  } = useStore();
  
  const menuRef = React.useRef<HTMLDivElement>(null);

  React.useEffect(() => {
    const handleClickOutside = (e: MouseEvent) => {
      if (menuRef.current && !menuRef.current.contains(e.target as Node)) {
        onClose();
      }
    };
    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [onClose]);

  const handleCopy = () => {
    navigator.clipboard.writeText(phrase.text);
    addLog('info', `–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ –±—É—Ñ–µ—Ä: "${phrase.text}"`);
    onClose();
  };

  const handleEdit = () => {
    const newText = prompt('–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ—Ä–∞–∑—É:', phrase.text);
    if (newText && newText.trim()) {
      editPhrase(phrase.id, newText.trim());
    }
    onClose();
  };

  const handleDelete = () => {
    if (confirm(`–£–¥–∞–ª–∏—Ç—å —Ñ—Ä–∞–∑—É "${phrase.text}"?`)) {
      deletePhrases([phrase.id]);
    }
    onClose();
  };

  const handleColor = (color: string) => {
    markRowColor(phrase.id, color);
    onClose();
  };

  const handleMove = (groupId: string) => {
    movePhrasesToGroup([phrase.id], groupId);
    onClose();
  };

  const handleAddToStopwords = () => {
    const words = phrase.text.split(' ');
    words.forEach(word => {
      addStopword({
        id: Date.now().toString() + Math.random(),
        text: word,
        matchType: 'partial',
        useMorphology: false,
        category: '–ò–ù–§–û–†–ú–ê–¶–ò–û–ù–ù–´–ï',
      });
    });
    addLog('success', `–î–æ–±–∞–≤–ª–µ–Ω–æ –≤ —Å—Ç–æ–ø-—Å–ª–æ–≤–∞: ${words.length} —Å–ª–æ–≤`);
    onClose();
  };

  return (
    <div
      ref={menuRef}
      className="fixed bg-white border border-gray-300 rounded shadow-lg py-1 z-50 min-w-[200px]"
      style={{ left: x, top: y }}
    >
      <button
        onClick={handleCopy}
        className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
      >
        –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å
      </button>
      <button
        onClick={handleEdit}
        className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
      >
        –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å
      </button>
      <div className="border-t my-1"></div>
      
      {/* –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤ –≥—Ä—É–ø–ø—É */}
      <div className="relative group/move">
        <button className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm">
          –ü–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –≤ –≥—Ä—É–ø–ø—É ‚Üí
        </button>
        <div className="hidden group-hover/move:block absolute left-full top-0 bg-white border border-gray-300 rounded shadow-lg py-1 min-w-[150px] ml-1">
          {groups.length === 0 ? (
            <div className="px-4 py-2 text-sm text-gray-500">–ù–µ—Ç –≥—Ä—É–ø–ø</div>
          ) : (
            groups.map(g => (
              <button
                key={g.id}
                onClick={() => handleMove(g.id)}
                className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
              >
                {g.name}
              </button>
            ))
          )}
        </div>
      </div>

      {/* –¶–≤–µ—Ç */}
      <div className="relative group/color">
        <button className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm">
          –¶–≤–µ—Ç ‚Üí
        </button>
        <div className="hidden group-hover/color:block absolute left-full top-0 bg-white border border-gray-300 rounded shadow-lg py-1 min-w-[120px] ml-1">
          <button onClick={() => handleColor('red')} className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm">
            üî¥ –ö—Ä–∞—Å–Ω—ã–π
          </button>
          <button onClick={() => handleColor('yellow')} className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm">
            üü° –ñ–µ–ª—Ç—ã–π
          </button>
          <button onClick={() => handleColor('green')} className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm">
            üü¢ –ó–µ–ª–µ–Ω—ã–π
          </button>
          <button onClick={() => handleColor('blue')} className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm">
            üîµ –°–∏–Ω–∏–π
          </button>
          <button onClick={() => handleColor('')} className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm">
            ‚ö™ –°–±—Ä–æ—Å–∏—Ç—å
          </button>
        </div>
      </div>

      <div className="border-t my-1"></div>
      <button
        onClick={() => {
          toggleRowLock(phrase.id);
          onClose();
        }}
        className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
      >
        {phrase.locked ? '–†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å' : '–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å'}
      </button>
      <button
        onClick={() => {
          useStore.getState().updatePhrase(phrase.id, { pinned: !phrase.pinned });
          addLog('info', phrase.pinned ? '–§—Ä–∞–∑–∞ –æ—Ç–∫—Ä–µ–ø–ª–µ–Ω–∞' : '–§—Ä–∞–∑–∞ –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–∞');
          onClose();
        }}
        className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
      >
        {phrase.pinned ? '–û—Ç–∫—Ä–µ–ø–∏—Ç—å' : '–ó–∞–∫—Ä–µ–ø–∏—Ç—å —Å–≤–µ—Ä—Ö—É'}
      </button>
      <button
        onClick={handleAddToStopwords}
        className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
      >
        –î–æ–±–∞–≤–∏—Ç—å –≤ —Å—Ç–æ–ø-—Å–ª–æ–≤–∞
      </button>
      {onShowHistory && (
        <button
          onClick={() => {
            onShowHistory(phrase.id);
            onClose();
          }}
          className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm"
        >
          üìú –ò—Å—Ç–æ—Ä–∏—è –∏–∑–º–µ–Ω–µ–Ω–∏–π
        </button>
      )}
      <div className="border-t my-1"></div>
      <button
        onClick={handleDelete}
        className="w-full text-left px-4 py-2 hover:bg-gray-100 text-sm text-red-600"
      >
        –£–¥–∞–ª–∏—Ç—å
      </button>
    </div>
  );
};

export const PhrasesTable: React.FC<{ onShowHistory?: (phraseId: string) => void }> = ({ onShowHistory }) => {
  const { 
    phrases, 
    selectedPhraseIds, 
    selectedGroupId,
    filters,
    columnVisibility,
    selectPhrase, 
    selectAll, 
    deselectAll,
    updatePhrase 
  } = useStore();
  
  const [sorting, setSorting] = React.useState<SortingState>([]);
  const [editingId, setEditingId] = React.useState<string | null>(null);
  const [editValue, setEditValue] = React.useState('');
  const [contextMenu, setContextMenu] = React.useState<{ x: number; y: number; phrase: Phrase } | null>(null);
  
  // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤
  const filteredPhrases = React.useMemo(() => {
    let result = phrases;

    // –§–∏–ª—å—Ç—Ä –ø–æ –≥—Ä—É–ø–ø–µ
    if (selectedGroupId) {
      result = result.filter(p => p.groupId === selectedGroupId);
    }

    // –ß–∏—Å–ª–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
    if (filters.wsMin !== undefined) {
      result = result.filter(p => p.ws >= filters.wsMin!);
    }
    if (filters.wsMax !== undefined) {
      result = result.filter(p => p.ws <= filters.wsMax!);
    }
    if (filters.qwsMin !== undefined) {
      result = result.filter(p => p.qws >= filters.qwsMin!);
    }
    if (filters.qwsMax !== undefined) {
      result = result.filter(p => p.qws <= filters.qwsMax!);
    }
    if (filters.bwsMin !== undefined) {
      result = result.filter(p => p.bws >= filters.bwsMin!);
    }
    if (filters.bwsMax !== undefined) {
      result = result.filter(p => p.bws <= filters.bwsMax!);
    }
    if (filters.lengthMin !== undefined) {
      result = result.filter(p => p.text.length >= filters.lengthMin!);
    }
    if (filters.lengthMax !== undefined) {
      result = result.filter(p => p.text.length <= filters.lengthMax!);
    }
    if (filters.wordCountMin !== undefined) {
      result = result.filter(p => p.text.split(/\s+/).length >= filters.wordCountMin!);
    }
    if (filters.wordCountMax !== undefined) {
      result = result.filter(p => p.text.split(/\s+/).length <= filters.wordCountMax!);
    }

    // –¢–µ–∫—Å—Ç–æ–≤—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
    if (filters.contains) {
      result = result.filter(p => p.text.toLowerCase().includes(filters.contains!.toLowerCase()));
    }
    if (filters.notContains) {
      result = result.filter(p => !p.text.toLowerCase().includes(filters.notContains!.toLowerCase()));
    }
    if (filters.startsWith) {
      result = result.filter(p => p.text.toLowerCase().startsWith(filters.startsWith!.toLowerCase()));
    }
    if (filters.endsWith) {
      result = result.filter(p => p.text.toLowerCase().endsWith(filters.endsWith!.toLowerCase()));
    }

    // –ë—ã—Å—Ç—Ä—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
    if (filters.showOnlyHighFreq) {
      result = result.filter(p => p.ws > 1000);
    }
    if (filters.showOnlyLowFreq) {
      result = result.filter(p => p.ws < 100 && p.ws > 0);
    }
    if (filters.showOnlyZeroFreq) {
      result = result.filter(p => p.ws === 0);
    }
    if (filters.showOnlyWithStopwords) {
      result = result.filter(p => p.hasStopword === true);
    }
    if (filters.showOnlySelected) {
      result = result.filter(p => selectedPhraseIds.has(p.id));
    }

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞: –∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–µ —Ñ—Ä–∞–∑—ã —Å–≤–µ—Ä—Ö—É
    result.sort((a, b) => {
      if (a.pinned && !b.pinned) return -1;
      if (!a.pinned && b.pinned) return 1;
      return 0;
    });

    return result;
  }, [phrases, selectedGroupId, filters, selectedPhraseIds]);
  
  // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–ª–æ–Ω–æ–∫ —Å —É—á–µ—Ç–æ–º –≤–∏–¥–∏–º–æ—Å—Ç–∏
  const columns = React.useMemo(() => {
    const cols: any[] = [
      // –ß–µ–∫–±–æ–∫—Å (–≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º)
      columnHelper.display({
        id: 'select',
        size: 60,
        header: ({ table }) => {
          const allSelected = filteredPhrases.length > 0 && 
            filteredPhrases.every(p => selectedPhraseIds.has(p.id));
          const someSelected = filteredPhrases.some(p => selectedPhraseIds.has(p.id));
          
          return (
            <Checkbox
              checked={allSelected}
              indeterminate={!allSelected && someSelected}
              onChange={() => {
                if (allSelected) {
                  deselectAll();
                } else {
                  selectAll();
                }
              }}
            />
          );
        },
        cell: ({ row }) => (
          <div className="flex items-center gap-1">
            {row.original.pinned && (
              <Pin className="w-3 h-3 text-blue-500 fill-blue-500" />
            )}
            {row.original.locked && (
              <Lock className="w-3 h-3 text-gray-500" />
            )}
            <Checkbox
              checked={selectedPhraseIds.has(row.original.id)}
              onChange={() => selectPhrase(row.original.id)}
            />
          </div>
        ),
      }),
      
      // –ù–æ–º–µ—Ä (–≤—Å–µ–≥–¥–∞ –≤–∏–¥–∏–º)
      columnHelper.display({
        id: 'index',
        size: 50,
        header: '‚Ññ',
        cell: ({ row }) => (
          <span className="text-gray-500">{row.index + 1}</span>
        ),
      }),
    ];

    // –§—Ä–∞–∑–∞
    if (columnVisibility.phrase !== false) {
      cols.push(
        columnHelper.accessor('text', {
          header: '–§—Ä–∞–∑–∞',
          size: 400,
          cell: ({ row }) => {
            const isEditing = editingId === row.original.id;
            
            if (isEditing) {
              return (
                <input
                  type="text"
                  value={editValue}
                  onChange={(e) => setEditValue(e.target.value)}
                  onBlur={() => {
                    if (editValue.trim()) {
                      updatePhrase(row.original.id, { text: editValue.trim() });
                    }
                    setEditingId(null);
                  }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      if (editValue.trim()) {
                        updatePhrase(row.original.id, { text: editValue.trim() });
                      }
                      setEditingId(null);
                    } else if (e.key === 'Escape') {
                      setEditingId(null);
                    }
                  }}
                  autoFocus
                  className="w-full px-2 py-1 text-sm border border-blue-500 rounded focus:outline-none focus:ring-2 focus:ring-blue-300"
                />
              );
            }
            
            return (
              <span
                onDoubleClick={() => {
                  setEditingId(row.original.id);
                  setEditValue(row.original.text);
                }}
                className="cursor-text"
              >
                {row.original.text}
              </span>
            );
          },
        })
      );
    }

    // ws
    if (columnVisibility.ws !== false) {
      cols.push(
        columnHelper.accessor('ws', {
          header: 'ws',
          size: 80,
          cell: ({ getValue }) => (
            <span className="text-gray-600 font-medium">
              {getValue() > 0 ? getValue().toLocaleString('ru-RU') : '-'}
            </span>
          ),
        })
      );
    }

    // qws
    if (columnVisibility.qws !== false) {
      cols.push(
        columnHelper.accessor('qws', {
          header: 'qws',
          size: 80,
          cell: ({ getValue }) => (
            <span className="text-gray-600 font-medium">
              {getValue() > 0 ? getValue().toLocaleString('ru-RU') : '-'}
            </span>
          ),
        })
      );
    }

    // bws
    if (columnVisibility.bws !== false) {
      cols.push(
        columnHelper.accessor('bws', {
          header: 'bws',
          size: 80,
          cell: ({ getValue }) => (
            <span className="text-gray-600 font-medium">
              {getValue() > 0 ? getValue().toLocaleString('ru-RU') : '-'}
            </span>
          ),
        })
      );
    }

    // –°—Ç–∞—Ç—É—Å
    if (columnVisibility.status !== false) {
      cols.push(
        columnHelper.accessor('status', {
          header: '–°—Ç–∞—Ç—É—Å',
          size: 80,
          cell: ({ getValue }) => {
            const status = getValue();
            return (
              <div className="flex items-center justify-center">
                {(status === 'done' || status === 'success') && (
                  <CheckCircle2 className="w-4 h-4 text-success-500" />
                )}
                {status === 'pending' && (
                  <div className="w-2 h-2 rounded-full bg-gray-300" />
                )}
                {status === 'error' && (
                  <div className="w-2 h-2 rounded-full bg-error-500" />
                )}
              </div>
            );
          },
        })
      );
    }

    return cols;
  }, [filteredPhrases, selectedPhraseIds, editingId, editValue, columnVisibility, selectPhrase, selectAll, deselectAll, updatePhrase]);
  
  const table = useReactTable({
    data: filteredPhrases,
    columns,
    state: {
      sorting,
    },
    onSortingChange: setSorting,
    getCoreRowModel: getCoreRowModel(),
    getSortedRowModel: getSortedRowModel(),
  });

  const handleContextMenu = (e: React.MouseEvent, phrase: Phrase) => {
    e.preventDefault();
    setContextMenu({ x: e.clientX, y: e.clientY, phrase });
  };
  
  if (filteredPhrases.length === 0) {
    return (
      <div className="flex-1 bg-white flex items-center justify-center">
        <div className="text-center text-gray-500">
          <p className="text-base mb-2">–ù–µ—Ç —Ñ—Ä–∞–∑ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è</p>
          <p className="text-sm">
            {selectedGroupId 
              ? '–í –≤—ã–±—Ä–∞–Ω–Ω–æ–π –≥—Ä—É–ø–ø–µ –Ω–µ—Ç —Ñ—Ä–∞–∑' 
              : Object.keys(filters).length > 0
              ? '–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Ñ—Ä–∞–∑ –ø–æ –∑–∞–¥–∞–Ω–Ω—ã–º —Ñ–∏–ª—å—Ç—Ä–∞–º'
              : '–î–æ–±–∞–≤—å—Ç–µ —Ñ—Ä–∞–∑—ã —á–µ—Ä–µ–∑ –∫–Ω–æ–ø–∫—É "–î–æ–±–∞–≤–∏—Ç—å" –∏–ª–∏ –∏–º–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Ñ–∞–π–ª'}
          </p>
        </div>
      </div>
    );
  }
  
  return (
    <div className="flex-1 bg-white overflow-auto">
      <table className="w-full border-collapse">
        <thead className="sticky top-0 bg-gray-100 z-10">
          {table.getHeaderGroups().map(headerGroup => (
            <tr key={headerGroup.id} className="border-b-2 border-gray-300">
              {headerGroup.headers.map(header => (
                <th
                  key={header.id}
                  style={{ width: header.getSize() }}
                  className={cn(
                    'h-10 px-3 text-left text-sm font-medium text-gray-700',
                    header.column.getCanSort() && 'cursor-pointer select-none hover:bg-gray-200'
                  )}
                  onClick={header.column.getToggleSortingHandler()}
                >
                  <div className="flex items-center gap-2">
                    {flexRender(header.column.columnDef.header, header.getContext())}
                    
                    {header.column.getIsSorted() && (
                      <span className="text-blue-500">
                        {header.column.getIsSorted() === 'asc' ? (
                          <ArrowUp className="w-4 h-4" />
                        ) : (
                          <ArrowDown className="w-4 h-4" />
                        )}
                      </span>
                    )}
                  </div>
                </th>
              ))}
            </tr>
          ))}
        </thead>
        
        <tbody>
          {table.getRowModel().rows.map((row, index) => {
            const isSelected = selectedPhraseIds.has(row.original.id);
            const isEven = index % 2 === 0;
            const phrase = row.original;
            const bgColor = phrase.color ? `bg-${phrase.color}-100` : '';
            const isPinned = phrase.pinned;
            
            return (
              <tr
                key={row.id}
                onContextMenu={(e) => handleContextMenu(e, phrase)}
                className={cn(
                  'h-9 border-b border-gray-200 transition-colors',
                  bgColor,
                  isPinned && !bgColor && 'bg-blue-50 border-blue-200',
                  isSelected && !bgColor && !isPinned && 'bg-blue-100 border-blue-200',
                  !isSelected && !bgColor && !isPinned && isEven && 'bg-white',
                  !isSelected && !bgColor && !isPinned && !isEven && 'bg-gray-50',
                  !isSelected && !bgColor && !isPinned && 'hover:bg-blue-50',
                  phrase.locked && 'opacity-60'
                )}
              >
                {row.getVisibleCells().map(cell => (
                  <td
                    key={cell.id}
                    className="px-3 text-sm text-gray-600"
                  >
                    {flexRender(cell.column.columnDef.cell, cell.getContext())}
                  </td>
                ))}
              </tr>
            );
          })}
        </tbody>
      </table>

      {/* –ö–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é */}
      {contextMenu && (
        <ContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          phrase={contextMenu.phrase}
          onClose={() => setContextMenu(null)}
          onShowHistory={onShowHistory}
        />
      )}
    </div>
  );
};
