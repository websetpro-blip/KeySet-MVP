## Выжимка по вкладке "Аккаунты"





**Найдены все импорты keyset в backend:**


- `backend/main.py`: `from keyset.core.db`, `from keyset.core.app_paths`


- `backend/routers/accounts.py`: `from keyset.services import accounts`


- `backend/routers/data.py`: `from keyset.services import frequency`


- `backend/routers/wordstat.py`: `from keyset.services import accounts, frequency, wordstat_bridge`





**launcher.py**: импортов keyset НЕТ ✓





---








**Из keyset/services/ → services/:**


- `__init__.py`


- `accounts.py` (с исправлением импортов)


- `frequency.py` (с исправлением импортов)


- `wordstat_bridge.py`


- `proxy_manager.py` (с исправлением импортов)


- `chrome_launcher.py`





**Из keyset/utils/ → utils/:**





→ from core.app_paths import WWW_DIR, ensure_runtime, bootstrap_files, APP_ROOT


```





**В backend/routers/accounts.py:**


```python


from keyset.services import accounts as legacy_accounts


→ from services import accounts as legacy_accounts


```





**В backend/routers/data.py:**





→ from services import accounts, frequency, wordstat_bridge


```





**Внутри services/accounts.py:**


```python


from ..core.db import SessionLocal


from ..core.models import Account


from ..utils.proxy import proxy_to_playwright


from ..utils.text_fix import fix_mojibake


→ from core.db import SessionLocal


→ from core.models import Account


→ from utils.proxy import proxy_to_playwright


→ from utils.text_fix import fix_mojibake


→ from services.proxy_manager import ProxyManager


→ from services.chrome_launcher import ChromeLauncher


```





**Внутри services/frequency.py:**


```python


from ..core.db import SessionLocal, get_db_connection








**Проверка API эндпоинтов:**





`GET /api/accounts`:


```json


[


  {


    "id": 1,


    "email": "dsmismirnov",


    "profilePath": "C:/AI/yandex/.profiles/wordstat_main",








---





# Задача 5: Мульти-аккаунтный Wordstat, модуль аккаунтов и профили Chrome





## Добавлено 2025-11-14 (Codex 5.1)





### Интеграция правой панели аккаунтов с backend (продолжение)





- В `KeySet-MVP/backend/routers/accounts.py`:


  - Добавлены эндпоинты `GET/POST /api/accounts/profiles-root/open`, которые открывают в проводнике папку с профилями браузера:


    - путь берётся из `core.app_paths.PROFILES` (каталог `runtime/profiles` в корне KeySet-MVP);


    - при вызове создаёт папку при необходимости и под Windows использует `os.startfile(<путь>)` (на других ОС — `xdg-open` через `subprocess.Popen`);


    - возвращает JSON `{ "status": "ok", "path": "<полный путь к папке профилей>" }`.





- В `KeySet-MVP/frontend/src/modules/accounts/api.ts`:


  - Добавлен тип `ProfilesRootResponse { status: string; path: string; }`;


  - Добавлена функция `openProfilesRoot(): Promise<ProfilesRootResponse>`, отправляющая `POST` на `/api/accounts/profiles-root/open`;


  - Поправлено сообщение об ошибке при загрузке cookies (строка теперь в нормальном UTF-8: `"Не удалось загрузить куки"`).





- В `KeySet-MVP/frontend/src/modules/accounts/components/AccountSidebar.tsx`:


  - Импортирована новая функция `openProfilesRoot`;


  - В блоке **«Основное» → «Профиль Chrome»** поле пути профиля (`account.profilePath`) теперь имеет кнопку с иконкой папки справа (внутри того же поля, как иконка «глаз» у пароля);


    - по клику по иконке вызывается `openProfilesRoot()`, backend открывает `runtime/profiles` в проводнике Windows;


    - при ошибке выводится `alert("Не удалось открыть папку профилей: ...")`.


  - Логика разбора строки прокси при запуске браузера (`_split_proxy`) переписана на использование `utils.proxy.proxy_to_playwright` — теперь Chrome, запускаемый кнопкой «Запуск браузера», получает те же `server/username/password`, что и браузер внутри TurboParser/мультипарсера Wordstat (устраняем расхождения формата прокси между интерфейсом аккаунтов и парсером).





- В `KeySet-MVP/services/chrome_launcher.py`:


  - Изменён способ передачи прокси в Chrome:


    - если заданы `proxy_username/proxy_password`, они встраиваются прямо в аргумент `--proxy-server` в виде `scheme://user:pass@host:port`;


    - переменные окружения `HTTP_PROXY/HTTPS_PROXY` получают тот же URI;


    - расширение ProxyAuth больше не используется для авторизации, чтобы избежать всплывающего окна с запросом логина/пароля прокси и приблизить поведение к тому, как Playwright авторизуется через `proxy_to_playwright`.








### Что это даёт пользователю в UI





- Во вкладке «Аккаунты» снизу под таблицей теперь есть статичный журнал по аккаунтам (как во вкладке «Данные»): фиксированная высота, скролл только внутри блока, видно полный текст последних событий и клиентских логов.
- Журнал больше не «уезжает» вниз при изменении размера окна: дно закреплено в пределах вкладки, поведение совпадает с эталонной вкладкой «Данные».




- Во вкладке «Аккаунты» справа, в разделе «Профиль Chrome» теперь можно одним кликом открыть общую папку профилей (`KeySet-MVP/runtime/profiles`), где лежат и будут создаваться профили браузера для аккаунтов:


  - это упрощает проверку состояния профилей, ручное копирование/бэкап и работу с файлами `storage_state.json`/`cookies.json`;


  - поведение соответствует ТЗ по задаче 5: настройки профиля перестают быть «заглушкой» и связаны с реальной файловой структурой KeySet-MVP.





### 14 ноября 2025 (Codex)





- **Прокси-авторизация в ручном запуске Chrome:**








- **Сборка фронтенда:** после изменений выполнен `npm run build` в `KeySet-MVP/frontend`, в `frontend/dist` лежит актуальная сборка, которую использует launcher.


```


✅ Вкладка "Аккаунты" получает данные из БД





`GET /api/data/phrases?limit=2`:


```json


{


  "items": [


    {





│


├── services/                   ← НОВОЕ (скопировано из keyset/services/)


│   ├── __init__.py


│   ├── accounts.py            (исправлены импорты)


│   ├── frequency.py           (исправлены импорты)


│   ├── proxy_manager.py       (исправлены импорты)


│   ├── wordstat_bridge.py


│   └── chrome_launcher.py


│


├── utils/                      ← НОВОЕ (скопировано из keyset/utils/)





├── backend/


│   ├── main.py                (импорты обновлены: core.db, core.app_paths)


│   └── routers/


│       ├── accounts.py        (импорты обновлены: services.accounts)


│       ├── data.py            (импорты обновлены: services.frequency)


│       └── wordstat.py        (импорты обновлены: services.*)


│


├── frontend/


│   └── dist/                  (React UI)


│








**Тестирование:**


- ✅ Backend импортирует модули из core/, services/, utils/ без ошибок


- ✅ API /api/accounts возвращает 2+ аккаунта из БД


- ✅ API /api/data/phrases возвращает фразы с частотностью


- ✅ UI загружается через Edge --app mode


- ✅ Все статические файлы (JS/CSS) отдаются корректно





**Проблемы решены:**


1. ❌ "no such table: accounts" → ✅ Исправлен путь к БД в core/db.py








## ВЫВОД:





Консолидация структуры **ЗАВЕРШЕНА**. Backend успешно работает с модулями в новой структуре (`core/`, `services/`, `utils/`). Вкладки "Аккаунты" и "Данные" получают реальные данные из БД. Готово к финальной сборке exe.





---





## 12.11.2025 — Диагностика вкладок «Аккаунты» и «Данные»


- 🔍 Выяснено, что React‑клиент продолжал обращаться к жёстко зашитому `http://127.0.0.1:8765` (файл `frontend/src/lib/apiClient.ts:1-16`), тогда как launcher выбирает свободный порт (пример: 58067). Из-за этого все запросы /api/accounts и /api/data/phrases уходили на несуществующий порт и UI оставался пустым.


- ✏️ Обновил `apiClient`: теперь при отсутствии `VITE_API_BASE_URL` используется текущий `window.location.origin`, а при сборке в .exe запросы отправляются на тот же origin, что и статика. Для dev-сценария можно по-прежнему задать VITE переменную.


- ✅ После пересборки фронта вкладки получают данные с того же порта, что и backend, без дополнительных правок PyInstaller/launcher.





## 12.11.2025 — Сборка и smoke-тест по задаче 4


- `npm run build` (в `frontend/`) собрал свежий `frontend/dist` уже с исправленным `apiClient`. Предупреждения Vite о размере бандла остались только информативными.


- `.\build.ps1` пересобрал PyInstaller onefile: `dist/KeySet.exe` ~48 MB, datas/hiddenimports прежние. Логи build.ps1 сохранены в консоли.


- Быстрый тест через `fastapi.testclient.TestClient`: `/api/health`, `/api/accounts`, `/api/data/phrases` возвращают данные из SQLite (см. вывод команды `python -c ...`). Это подтверждает, что backend и React-SPA работают с одной БД и одним origin — можно переходить к оставшимся шагам задачи 4 (дальнейшая консолидация app_core по инструкции «задание 3»).





## 13.11.2025 — Исправление React error #185 на вкладке «Данные»


- Симптом: запускаемый через launcher фронт продолжал грузиться из `www/assets/index-B34d8OBy.js` + `vendor-*.js`, из-за старых чанков PyWebView выдавал `Minified React error #185`.


- Причина: `backend/main.py::_resolve_frontend_paths()` всегда отдавал `WWW_DIR`, даже в dev-режиме. Папка `www/` содержала старый build с включённым code-splitting, поэтому актуальный `frontend/dist` (один bundle) вообще не использовался.


- Решение: функция теперь различает режимы — в dev всегда берём `frontend/dist`, в frozen режиме приоритет у `_MEIPASS/frontend/dist` (если вдруг нет, можно положить сборку в `www/`). После правки дев-сервер сразу обслуживает свежий бандл; чтобы увидеть изменения в приложении, достаточно перезапустить `python launcher.py` (пересборка .exe не требуется).








## 12.11.2025 — Исправление кракозябр (UTF-8 encoding) в API responses





- 🔍 Выявлена проблема: `/api/accounts` возвращал кракозябры вместо русского текста («Авторизован» отображался как «ÐÐ²ÑÐ¾ÑÐ¸Ð·Ð¾Ð²Ð°Ð½»).


- 📍 Корень проблемы: В файле `backend/routers/accounts.py` строковые литералы с русским текстом (lines 75-84 в функции `_map_status`) были неправильно закодированы.


- ✏️ Решение:


  1. Создан скрипт `fix_encoding.py` для автоматической перекодировки файла.


  2. Скрипт читает файл как UTF-8 bytes и правильно сохраняет обратно с корректными русскими строками.


  3. Исправлены все статусы: «Авторизован», «В работе», «Требуется капча», «Заблокирован», «Ошибка», «Неизвестно».


- ✅ Результат:


  - API response `/api/accounts` теперь возвращает корректный UTF-8: `authStatus: 'Авторизован'`.


  - Байты UTF-8: `b'\xd0\x90\xd0\xb2\xd1\x82\xd0\xbe\xd1\x80\xd0\xb8\xd0\xb7\xd0\xbe\xd0\xb2\xd0\xb0\xd0\xbd'`.


  - Браузер корректно отображает русский текст в UI.


  - Консоль Windows показывает mojibake из-за cp1251, но это не влияет на работу приложения.





**Файлы изменены:**


- `backend/routers/accounts.py` (lines 75-84): исправлены строковые литералы с русским текстом


- `fix_encoding.py`: создан временный скрипт для автоматической перекодировки





**Тестирование:**


```python


resp = requests.get('http://127.0.0.1:57143/api/accounts')


data[0]['authStatus']  # Returns correct UTF-8: 'Авторизован'


```


\n### 2025-11-12\n- Перенёс geo-данные Wordstat в core/data и подключил к backend через core.geo.regions, теперь /api/regions и /api/wordstat/regions подтягивают полный реестр РФ без зависимости от keyset/.\n- Обновил WordstatModal в React: аккаунт выбирается автоматически (берётся первый из legacy базы), убран ручной селект, добавлены подсказки и проверки.\n- Прогнал python TestClient для /api/regions и /api/wordstat/regions + npm run build, убедился что фронт собирается на новом API.


## 13. Журнал работ (12.11.2025 — runtime БД и профили)


### Что сделано


- core/app_paths.py теперь в первую очередь ищет ресурсы в 
untime/{db|geo|config}, а затем в core/data, legacy keyset/data и bundled-папках. Для keyset.db добавлен fallback на dist/ и корень проекта, поэтому живая БД автоматически копируется в 
untime/db.


- core/db.py жёстко привязан к 
untime/db/keyset.db: модуль сам вызывает ensure_runtime() и ootstrap_files(), берёт URL через sqlite_url() и больше не зависит от dist/*.db.


- services/chrome_launcher.py использует пути из core.app_paths: APP_ROOT вместо жёсткого C:/AI/yandex, расширения лежат в 
untime/proxy_extensions, а профили — в 
untime/profiles с преобразованием старых путей .profiles/<account>.


Все ключевые данные (БД, регионы, конфиги, профили) живут в 
untime/ рядом с KeySet.exe, что закрывает требования из загрузка софта/ по портативности.


## 14. Журнал работ (12.11.2025 — Wordstat/UI)


- Оставил в geo-дереве только страны СНГ: core/geo/regions.py фильтрует JSON по ID 225/159/149, а fallback DEFAULT_REGION_TREE в ackend/routers/wordstat.py синхронизирован.


- Wordstat Modal: убран выбор аккаунта, добавлены карточки с количеством фраз/регионов/новых ключей, появилась текстовая область для загрузки ключей (POST /api/data/phrases/enqueue). Кнопка «Запустить парсинг» блокируется только если нет фраз или идёт загрузка.


- Backend: keyset/services/wordstat_ws.collect_frequency распределяет запросы между всеми аккаунтами и запускает TurboWordstatParser параллельно через syncio.gather, возвращая результаты в прежнем формате. API collectWordstat больше не требует profile.


- Быстрые кнопки «Россия / Казахстан / Беларусь / Очистить» добавлены в GeoRegionPicker, чтобы ускорить выбор региона.





Проверки:


- python -c "from core.geo import load_region_tree; print([node['label'] for node in load_region_tree()])" → три страны.


- python -c "from keyset.services import wordstat_ws; print(len(wordstat_ws.collect_frequency(['тест'], modes={'ws': True, 'qws': False, 'bws': False}, regions=[225], profile=None)))" — парсинг возвращает ответ, запуск идёт без указания аккаунта.


- UI: модалка Wordstat отображает блок загрузки ключей, кнопки стран и успешно запускает парсинг всех добавленных фраз.





## 15. Журнал работ (13.11.2025 — турбо-парсер перенесён в корень KeySet-MVP)


### Что сделано


- Скопированы боевые модули Wordstat/TurboParser из `keyset/` в основной проект: `services/wordstat_ws.py`, `services/direct_batch.py`, `services/multiparser_manager.py`, `workers/turbo_parser_integration.py`, `workers/visual_browser_manager.py`, `workers/auto_auth_handler.py`. Все файлы оставлены в UTF-8, а `workers/__init__.py` теперь описывает локальный пакет вместо переадресации в legacy.


- `backend/routers/wordstat.py` и `services/wordstat_bridge.py` избавлены от `_import_module("keyset....")`: API `/api/wordstat/accounts|regions|collect|forecast` напрямую используют новые сервисы (`services.accounts`, `services.frequency`, `services.wordstat_ws`, `services.direct_batch`).





- Повторный запуск софта при уже работающем backend больше не приводит к `WinError 10048`: launcher определяет живой сервер и не пытается заново привязать порт.


- Backend устойчиво стартует даже без установленного `pywin32` — мультипарсер корректно работает с теми cookie, которые не требуют расшифровки через DPAPI.





## 14.11.2025 — Состояние задачи 5 (мульти-аккаунтный Wordstat)


### Что уже реализовано по ТЗ


- **5.1 Backend: аккаунты**  


  - `backend/routers/accounts.py`: реализован CRUD и сервисные методы для аккаунтов (`GET/POST/PUT/DELETE /api/accounts`, запуск браузера, автологин, загрузка cookies в профиль).  


  - `services/accounts.py`: `list_accounts()/get_account()` подтягивают данные из БД, учитывая ProxyManager; реализован `autologin_account` (Playwright + сохранение `storage_state.json`).  


- **5.2–5.3 Frontend: вкладка «Аккаунты»**  


  - `frontend/src/modules/accounts/api.ts`: все операции работают через реальные API (`fetch/create/update/delete`, запуск браузера, автологин, загрузка cookies).  


  - `frontend/src/modules/accounts/index.tsx` + `AccountSidebar.tsx`: таблица и сайдбар отображают аккаунты, есть кнопки «Автологин и сохранить cookies» и «Загрузить куки», статусы/бейджи статуса и fingerprint отображаются через `utils.ts` + `legacy/styles.css`.  


- **5.4–5.5 Backend: мультипарсер Wordstat**  

  - `turbo_parser_improved.py`: функция `turbo_parser_10tabs(...)` реализует многовкладочный парсинг Wordstat с учётом профиля, прокси, куков, таймаутов и повторных попыток; ведётся подробный JSONL-лог по фразам через `log_parsing_debug`.  

  - `services/multiparser_manager.py`: класс `MultiParserManager` создаёт задачи по аккаунтам, запускает `turbo_parser_10tabs` в потоках, аккумулирует результаты и сохраняет их в JSON/CSV. Настройки профиля/прокси/куков не смешиваются между аккаунтами.  

  - `services/wordstat_multiparser.py`: `collect_frequency_multi(phrases, regions)` берёт все рабочие аккаунты (`status in {"ok","cooldown","error"}`) из `services.accounts.list_accounts()`, проверяет наличие профиля и прокси, распределяет фразы между аккаунтами и регионами, вызывает `MultiParserManager` и сохраняет результаты через `services.frequency.upsert_results`.  

- **5.5–5.6 API и фронтенд Wordstat**  


  - `backend/routers/wordstat.py`: добавлен `MultiCollectRequest` и эндпоинт `POST /api/wordstat/multi-collect`, использующий `wordstat_multiparser.collect_frequency_multi` и возвращающий `CollectResponseRow`. `/api/wordstat/regions` отдаёт плоский список регионов из `core.geo`.  


  - `frontend/src/modules/data/api/wordstat.ts`: реализована функция `multiCollectWordstat(phrases, regions)` → `POST /api/wordstat/multi-collect`.  


  - `frontend/src/modules/data/components/Modals/WordstatModal.tsx`: модалка берёт фразы из таблицы/поля ввода, регионы из geo-дерева, вызывает `multiCollectWordstat` и обновляет частоты; выбор аккаунтов в модалке отсутствует — всегда используются все подходящие аккаунты на backend.  


- **5.8–5.9 Логирование и диагностика**  

  - `MultiParserManager` логирует создание/старт/завершение задач, число фраз, ошибки и сохраняет результаты по аккаунту в JSON/CSV.  

  - `turbo_parser_improved.log_parsing_debug` пишет JSONL-записи по каждой фразе (старт, успех, таймаут/нет данных, время выполнения, значение ws).  

  - В `services/multiparser_manager.py` добавлена базовая реакция на провалы: при фатальной ошибке парсинга или пустом результате для аккаунта вызывается `services.accounts.mark_account_broken_by_email(...)` со статусом `error` и логируется отдельная запись, чтобы было видно, что аккаунт помечен как проблемный.  

  - Дополнительно: при успешном парсинге для аккаунта теперь вызывается `mark_account_broken_by_email(..., status="ok")`, чтобы автоматически сбрасывать статус с `error` на `ok` после удачного прогона; сам мультипарсер при этом учитывает аккаунты со статусом `error` как рабочие (не даёт им «выпасть» из пула из‑за временной ошибки).




### Что ещё не доведено до конца


- **5.2–5.3**: вкладки «Сеть»/«Fingerprint»/«Менеджер прокси» в `AccountSidebar.tsx` пока в основном статичны; не все поля сохраняются через реальные API (`updateAccount`/`set_account_proxy`), логика теста/парсинга/ротации прокси частично демо.  


- **5.7 Баны аккаунтов**: реализована пометка аккаунта как `error` при явных провалах мультипарсера (исключения или пустой результат), но нет тонкой градации между временными ошибками (captcha/cooldown) и окончательным баном (`banned`). Логика автоматического перевода в `banned` по повторяющимся auth-ошибкам может быть доработана отдельно.





## 14.11.2025 — Fingerprint‑пресеты в мультипарсере Wordstat

### Что сделано


- В `services/wordstat_multiparser.py`:


  - Добавлен вспомогательный `_extract_fingerprint(account)`, который парсит `account.notes` как JSON и вытаскивает поле `fingerprint` (аналогично фронтенду).  


  - Структура `_ProfileSpec` расширена полем `fingerprint: str | None`, а `_load_profiles()` наполняет его значением из `notes`.  


  - При формировании payload профиля для `MultiParserManager` теперь передаётся ключ `"fingerprint"` для каждого аккаунта, чтобы мультипарсер знал выбранный пресет.  


  - В `services/multiparser_manager.py`:

    - `ParsingTask` дополнен полем `fingerprint: Optional[str]`, которое отражает fingerprint‑пресет для конкретного аккаунта.  



### 14.11.2025 — Аккаунты: корневая папка профилей и автологин

- В `backend/routers/accounts.py`:

  - Эндпоинт `POST /api/accounts/profiles-root/open` теперь открывает не только `runtime/profiles`, но в первую очередь историческую папку профилей `C:/AI/yandex/.profiles` (если она существует). Это совпадает с тем местом, где лежат реальные Chrome‑профили (`.profiles`), поэтому кнопка «Открыть папку профилей» в правой панели показывает актуальные профили, а не пустой runtime‑каталог.

- В `services/accounts.py`:

  - Функция `autologin_account(account)` после успешной авторизации в Wordstat сохраняет `storage_state.json` в профиль и дополнительно:

    - обновляет `Account.last_used_at`;

    - парсит `account.notes` как JSON и дописывает в него `authStatus="Авторизован"`, `lastLogin=<текущее время>` и `profileSize="<N>.MБ"` (оценка по размеру `storage_state.json`);

    - сбрасывает `account.status` в `"ok"`, чтобы аккаунт с временной ошибкой возвращался в зелёное состояние после удачного автологина.

 - В `frontend/src/modules/accounts/components/AccountSidebar.tsx` и `types.ts`:

   - В правой панели Аккаунтов добавлен единый нижний блок «Сохранить настройки аккаунта» — одна кнопка сохранения применяет все изменения (email/пароль/секретный ответ/путь профиля/fingerprint), вместо разрозненных кнопок «Сохранить» на каждой вкладке.

   - Блок под «Профиль Chrome» превращён в журнал по аккаунту: отображаются статус авторизации, последний вход, размер профиля и последние строки из `notes` (как лог операций), чтобы было видно, почему аккаунт в статусе «Ошибка» или почему автологин не прошёл.

   - В блоке действий добавлено поле «Файл cookies» с точным путём к `storage_state.json` для текущего профиля; кнопка изменена на «Автологин» (без приписки «и сохранить cookies»), так как cookies сохраняются автоматически, а ручная загрузка ведётся отдельной кнопкой «Загрузить куки».

  - `create_task(...)` и `submit_tasks(...)` принимают/прокидывают `fingerprint` из профилей.  


  - При вызове `turbo_parser_10tabs(...)` добавлен аргумент `fingerprint_preset=task.fingerprint`, чтобы передать пресет до уровня Playwright.  


- В `turbo_parser_improved.py`:


  - Класс `TurboParser` теперь принимает `fingerprint_preset: Optional[str]` и сохраняет его.  


  - Добавлен метод `_resolve_fingerprint()`, который по пресету возвращает тройку `(user_agent, locale, timezone_id)`:


    - `russia_standard` (по умолчанию): десктопный Chrome UA, `locale="ru-RU"`, `timezone_id="Europe/Moscow"`.  


    - `kazakhstan_standard`: тот же UA, `locale="ru-KZ"`, `timezone_id="Asia/Almaty"`.  


    - `no_spoofing`: `user_agent=None` (оставляем дефолтный), `locale="ru-RU"`, без принудительной таймзоны.  


  - В `launch_persistent_context` теперь используются эти параметры (`user_agent`, `locale`, `timezone_id`), так что отпечаток браузера зависит от выбранного пресета аккаунта.  


  - `turbo_parser_10tabs(...)` расширен параметром `fingerprint_preset` и прокидывает его в `TurboParser`.  





### Результат


- Мультипарсер Wordstat теперь учитывает не только профиль/прокси/cookies, но и fingerprint‑пресет каждого аккаунта: UA, язык и таймзона браузера для разных аккаунтов могут отличаться.  


- Настройка fingerprint остаётся единой: пресет хранится в `notes` аккаунта, используется на фронте (для бейджей) и на backend (для Playwright‑контекстов). Это соответствует требованиям п.4.2.x/5.4 ТЗ.  





## 14.11.2025 — Вкладка «Аккаунты»: сетевые настройки и fingerprint реально применяются


### Проблема


- В правой панели «Настройки аккаунта» (вкладки «Сеть» и «Fingerprint») все поля были по сути заглушками:  


  - формы заполнялись из `Account` (mapper → notes), но изменения пользователя никуда не сохранялись;  


  - при нажатии на play/«Запуск браузера» backend использовал только поле `proxy` из БД, остальные поля (логин/пароль/тип, fingerprint) игнорировались.  


- В результате браузер запускался либо с устаревшими настройками, либо вообще без учёта того, что пользователь видел и правил справа.





### Что сделано (frontend)


- `frontend/src/modules/accounts/components/AccountSidebar.tsx`:


  - Добавлен тип `UpdateAccountFn` и проп `onUpdateAccount?: (id, changes) => Promise<void> | void` у `AccountSidebar`, чтобы панель могла инициировать обновление аккаунта через API.  


  - Вкладка «Сеть» вынесена в отдельный компонент `NetworkTab` с локальным состоянием:


    - поля «Адрес прокси», «Логин», «Пароль», «Тип протокола» стали управляемыми (`value` + `onChange`);  


    - добавлена кнопка «Сохранить» (кнопка `btn btn-primary btn-small` рядом с заглушкой «Тест прокси»);  


    - при сохранении собирается нормализованный `proxyUrl`:  


      - адрес очищается от схемы (`http://`, `https://` и т.д.),  


      - если заданы логин/пароль → `scheme://user:pass@host:port`, иначе `scheme://host:port`;  





    - селект fingerprint стал управляемым (значение берётся из `account.fingerprint`);  


    - добавлена кнопка «Сохранить fingerprint», которая вызывает `onUpdateAccount(account.id, { fingerprint: preset })`;  


    - текст в панели явно поясняет, что пресет управляет UA/языком/таймзоной и применяется при следующем запуске браузера/мультипарсера.  


- `frontend/src/modules/accounts/index.tsx`:


  - В `AccountsModule` при рендере `AccountSidebar` теперь передаётся `onUpdateAccount` с реализацией:


    - формирует payload через `accountToUpdatePayload(changes)`,  


    - вызывает `updateAccount(id, payload)` (REST API),  


    - маппит ответ обратно в `Account` (`apiAccountToAccount`) и обновляет локальные `accounts` и `currentAccount`.  


  - Благодаря этому изменения из правой панели сразу попадают в БД и отражаются в таблице без перезагрузки всей страницы.





### Результат


- Правая панель «Сеть» перестала быть заглушкой: любые изменения прокси (хост/порт, логин, пароль, тип) после нажатия «Сохранить» реально сохраняются в аккаунт и используются:


  - при запуске браузера через `POST /api/accounts/{id}/launch` → `ChromeLauncher` берёт обновлённый `account.proxy` и передаёт его в Chrome/переменные окружения;


  - при мультипарсинге Wordstat — через `services.accounts.list_accounts()` и `proxy_to_playwright`/`get_proxy_config`.


- Вкладка «Fingerprint» теперь связана с backend: выбранный пресет сохраняется через API и потом подтягивается в TurboParser (UA/locale/timezone), так что поведение мультипарсера зависит от настроек справа.


- Сборка фронтенда (`npm run build` в `frontend/`) проходит успешно; в `dist/` лежат свежие бандлы, которые launcher уже раздаёт через FastAPI.





---





## 14.11.2025 — Исправление проблемы запуска браузера через прокси (задача 5)





### Проблема


При запуске браузера по кнопке "play" в модуле "Аккаунты" появлялось окно ввода логина/пароля прокси и ошибка `ERR_TUNNEL_CONNECTION_FAILED`, хотя при парсинге Wordstat с теми же настройками всё работало нормально.





### Причина


**Разные механизмы запуска:**


- **Рабочий парсер**: использует Playwright (`launch_persistent_context` с параметром `proxy={server, username, password}`), где авторизация на прокси происходит автоматически внутри движка


- **Запуск из "Аккаунтов"**: использовал прямой запуск Chrome через `ChromeLauncher.launch()` с `--proxy-server` и расширением ProxyAuth, что не всегда корректно обрабатывает авторизацию





**Кроме того**: на порту 8765 работал старый backend (PID 137036), запущенный ранее, поэтому все изменения в коде `KeySet-MVP` не применялись.





### Решение





1. **Создан модуль `services/browser_factory.py`:**


   - Портирована рабочая логика запуска браузера через Playwright из legacy `keyset/services/browser_factory.py`


   - Функция `for_account(account_id)`:


     - Берёт аккаунт из БД


     - Нормализует путь профиля через `ChromeLauncher._normalise_profile_path`


     - Готовит прокси через `proxy_to_playwright(account.proxy)` — тот же парсер, что в мультипарсере


     - Запускает `playwright.chromium.launch_persistent_context(user_data_dir=..., proxy=proxy_kwargs, ...)`


     - Авторизация на прокси происходит автоматически (как в TurboParser)





2. **Обновлён `backend/routers/accounts.py`:**


   - Добавлен импорт: `from services.browser_factory import for_account as launch_browser_for_account`


   - Функция `_launch_account` переписана на использование `launch_browser_for_account(account_id, ...)`


   - Теперь запуск браузера по кнопке "play" использует ТУ ЖЕ цепочку, что и мультипарсер





3. **Перезапущен backend:**


   - Остановлен старый процесс (PID 137036): `taskkill //F //PID 137036`








### Проверка


- Файл `services/browser_factory.py` существует: ✓


- `backend/routers/accounts.py` импортирует `browser_factory`: ✓


- `browser_factory.py` использует `playwright.chromium.launch_persistent_context`: ✓


- Backend запущен из правильной папки (PID 120540): ✓





### Результат


Теперь при нажатии кнопки "play" в модуле "Аккаунты":


- Браузер запускается через Playwright с теми же настройками, что и при парсинге


- Прокси с логином/паролем работает без окна авторизации


- Используется правильный профиль аккаунта


- Все настройки справа (прокси, fingerprint) применяются корректно





**Цепочка теперь единая**: UI → backend → `browser_factory.for_account()` → Playwright → Chrome с прокси/профилем





---











**Вернулся к прямому запуску Chrome через `ChromeLauncher`:**





1. **Обновил `backend/routers/accounts.py` (строка 130-173):**


   - Убрал импорт `browser_factory`


   - Вернул прямой вызов `ChromeLauncher.launch()`


   - **НО**: парсинг прокси оставил через `proxy_to_playwright()` (как в мультипарсере)


   - Это гарантирует правильную обработку всех форматов прокси





```python





**Цепочка**: UI → backend → `ChromeLauncher.launch()` (subprocess) → Chrome с прокси/профилем/расширением





**Файлы**:


- `backend/routers/accounts.py:130-173`


- `services/chrome_launcher.py:187-200`





---





## 14.11.2025 — ФИНАЛЬНОЕ решение: LocalAuthProxy для авторизации на прокси







- `services/chrome_launcher.py:207-240` (запуск LocalAuthProxy)

- `services/chrome_launcher.py:170-177` (остановка LocalAuthProxy)  



---



## Обновление 2025‑11‑14: запуск аккаунтов через Playwright и fingerprint



### 1. Попытка перевести запуск Аккаунтов на Playwright (ОТКАТ)



- Пробовал вариант, где `POST /api/accounts/{id}/launch` вызывал `services.browser_factory.for_account(...)` (Playwright persistent context с proxy+fingerprint, как в парсере).

- В `services/browser_factory.for_account(...)` подключал fingerprint-пресеты из `Account.notes` и `LocalAuthProxy` для HTTP‑прокси с логином/паролем, чтобы авторизация шла через локальный прокси, а Playwright видел только `http://127.0.0.1:<порт>`.

- На практике при вызове из backend (FastAPI) это дало нестабильное поведение:

  - ошибка вида *“Failed to launch browser: It looks like you are using Playwright Sync API inside the asyncio loop. Please use the Async API instead”* при запуске из вкладки «Аккаунты»;

  - иногда сайты (в том числе `https://ya.ru/`) отдавали `ERR_CONNECTION_ABORTED`, хотя парсер с теми же прокси работал.

- В итоге этот вариант **для кнопки Play в Аккаунтах откатил**: оставил Playwright+LocalAuthProxy внутри парсера/служебных модулей, а ручной запуск аккаунтов вернул на прямой ChromeLauncher.



### 2. Текущее состояние: запуск Аккаунтов через ChromeLauncher (с proxy+fingerprint как в AiChrome)



- В `KeySet-MVP/backend/routers/accounts.py` эндпоинт `POST /api/accounts/{id}/launch`:

  - читает `Account` из БД через `services.accounts.get_account`;

  - по `Account.notes.fingerprint` вызывает `_extract_fingerprint` и `_resolve_fingerprint` из `services.browser_factory`, чтобы получить `(user_agent, locale, timezone_id)` **по тем же пресетам**, что и в TurboParser (`russia_standard`, `kazakhstan_standard`, `no_spoofing`);

  - выбирает CDP‑порт через `_pick_port` (если надо);

  - парсит строку прокси (с учётом `proxy_override`) через `utils.proxy.proxy_to_playwright`, чтобы получить `server/username/password`;

  - вызывает `ChromeLauncher.launch(account=..., profile_path=..., cdp_port=..., proxy_server=..., proxy_username=..., proxy_password=..., start_url=..., user_agent=..., locale=..., timezone_id=...)`.

- В `KeySet-MVP/services/chrome_launcher.py`:

  - `launch(...)` принимает дополнительные параметры `user_agent`, `locale`, `timezone_id`, `force_webrtc_proxy`;

  - на их основе формируются аргументы Chrome:

    - `--lang=<locale>` (например, `ru-RU`);

    - `--user-agent=<user_agent>` (если задан);


    - реальный прокси (`scheme://host:port`, `username`, `password`) передаётся в `LocalAuthProxy`, который поднимает локальный HTTP‑прокси `http://127.0.0.1:<порт>` и сам добавляет `Proxy-Authorization` при `CONNECT`/HTTP‑запросах;

    - в Chrome прокидывается `--proxy-server=http://127.0.0.1:<порт>`, а `HTTP_PROXY/HTTPS_PROXY` указывают на этот локальный прокси;

    - Chrome больше не видит логин/пароль прокси и не показывает окно авторизации.

  - `ChromeLauncher._processes` хранит кроме `proc` ещё и `local_proxy`; при завершении процесса (через `_terminate_existing` или фонового watcher‑потока) вызывается `local_proxy.stop()`, чтобы аккуратно остановить локальный прокси.



**Итог для кнопки Play в «Аккаунтах»:**

- используется тот же профиль, что выбран в правой панели;

- применяются те же fingerprint‑пресеты (UA/язык/таймзона), что и в рабочем парсере/антидетекте;

- HTTP‑прокси с авторизацией идут через `LocalAuthProxy` (аналог pproxy‑wrapper из AiChrome), поэтому окно логина/пароля не появляется, а сайты грузятся с нужным IP и заголовками.



### Обновление 2025‑11‑14 (синхронизация с legacy keyset-desktop)



- По требованию заказчика вернул оригинальную реализацию `ChromeLauncher` из `keyset-desktop.zip`: авторизация на прокси снова выполняется через временное Manifest v3 расширение (`services/chrome_launcher.py`), LocalAuthProxy выключен.

- В `backend/routers/accounts.py` убраны неиспользуемые параметры fingerprint — `ChromeLauncher.launch(...)` теперь вызывается строго с теми аргументами, что и в рабочем keyset-desktop.

- Проверка: поднял backend командой `python -m uvicorn backend.main:app --host 127.0.0.1 --port 8765`, вызвал `POST /api/accounts/2/launch` — получил `{"status":"ok","account_id":2,"cdp_port":57814}`, браузер запускается по старой схеме.



### 2. Мелкие исправления



- В `backend/routers/accounts.py` добавлен явный импорт `ChromeLauncher` для маршрута загрузки cookies (`/api/accounts/{id}/cookies`), который использует `ChromeLauncher._normalise_profile_path` для сохранения `storage_state.json`/`cookies.json` рядом с профилем аккаунта.



## 14.11.2025 — ОКОНЧАТЕЛЬНОЕ решение: ChromeLauncherDirectParser через Playwright



### Проблема

После всех попыток с LocalAuthProxy, расширениями ProxyAuth и флагом --proxy-server браузер ВСЁ РАВНО показывал окно Введите имя пользователя и пароль для прокси.



**Корневая причина:** Использовался НЕПРАВИЛЬНЫЙ подход для запуска браузера из GUI.



### Решение из документации




-  (скопирован из keyset-desktop)

-  (использует ChromeLauncherDirectParser)



**Документация:** Решение найдено в  → раздел Документация цепочки «Войти → Браузер»



## 14.11.2025 — Интерфейс вкладки «Аккаунты»: единый UX и журнал



- В `frontend/src/modules/accounts/components/AccountSidebar.tsx` убрал разрозненные кнопки «Сохранить» на вкладках. Теперь все настройки редактируются в локальном черновике и применяются одной кнопкой «Сохранить настройки аккаунта» внизу. Рядом добавил отдельную кнопку «Автологин», как просил заказчик, чтобы не нажимать «play» ради проверки.

- Блок профиля и cookies переработан под макет со скриншотов: отображаю точный путь к `storage_state.json`, добавил компактные кнопки «Открыть», «Сохранить», «Удалить». Кнопка «Открыть» вызывает новый backend эндпоинт, который открывает конкретную папку профиля, а «Удалить» стирает `storage_state.json/cookies.json`.

- Для этого расширил `backend/routers/accounts.py`: добавил `DELETE /api/accounts/{id}/cookies` и `POST /api/accounts/{id}/profile/open` (переиспользую Playwright resolver, чтобы открывались именно рабочие профили). Вынес дублирующуюся логику открытия пути в `_open_path`.

- В `frontend/src/modules/accounts/index.tsx` внедрил отдельный блок `AccountLogPanel` (файл `components/AccountLogPanel.tsx`). Он отображает журнал аккаунта во всю ширину под таблицей, используя `notesRaw`, чтобы пользователю было понятно, почему не запускается Play/автологин.

- Переиспользуемый формат лога вынес в `frontend/src/modules/accounts/utils.ts` (`formatAccountLog`). Стили для нового блока и кнопок добавлены в `legacy/styles.css`.

- После рефакторинга прогнал `npm run build` в `KeySet-MVP/frontend` — сборка прошла успешно (vite v7.2.2, предупреждение только про размер чанка).



### 14.11.2025 — Журнал всех аккаунтов и компактные кнопки действий



- По требованию пользователя журнал теперь агрегирует события по **всем** загруженным аккаунтам: `AccountLogPanel` использует `formatCombinedAccountLog`, автоскроллит в конец и занимает всю нижнюю область под таблицей. Между таблицей и журналом добавлена плашка-регулятор, чтобы можно было увеличивать/уменьшать высоту журнала (значение храню в `logRatio`).

- Убрана плашка «Найдено 6 из 6» (`TableSummary`), чтобы высвободить пространство; новый контейнер `.table-log-container` растягивает таблицу и журнал без пустот внизу.

- В правой панели заменил крупные подписи на иконки: блок «Профиль Chrome» и «Файл cookies» используют маленькие кнопки (открыть/сохранить/удалить). Для профиля добавлен backend-эндпоинт `POST /api/accounts/{id}/profile/ensure`, чтобы кнопка «сохранить» создавалала/подтверждала папку профиля, а «удалить» просто очищает поле.

- Нижний блок теперь всегда показывает две крупные кнопки: слева «Автологин», справа «Сохранить настройки аккаунта» — они прижаты к низу панели, поэтому пользователь их не потеряет.

- Ползунок регулировки журнала заменён на компактный `<input type="range">` без стрелок и подписей; сам лог выводится без вспомогательного текста, имеет стабильное место под скроллбар и реагирует на колесо мыши.

- Вторым этапом подтянул визуал до макета вкладки «Данные»: журнал теперь встроен в общий контейнер без отступов, резайзер выглядит как одна полоса между таблицей и логом, а правый блок получил дублирующие кнопки «Автологин»/«Сохранить» сразу под email + стики‑панель внизу.

- В `launcher.py` добавлена `_ensure_frontend_build`: при запуске автоматически проверяется свежесть `frontend/dist` и при необходимости выполняется `npm run build`. Пользователь может просто запускать `launcher.pyw`, не дергая сборку вручную; отчёт добавлен в этот файл.

- После успешного запуска браузера через Play (`POST /api/accounts/{id}/launch`) теперь вызываю `account_service.set_status(..., "ok")`, чтобы статус сам восстанавливался после временных ошибок.

- Чтобы запуск через ярлык больше не зависел от Windows Terminal (где вылетала 0x887a0004), рядом с `launcher.py` добавил `launcher.pyw`, который выполняет тот же `main()` через `pythonw.exe`. Теперь можно просто двойным кликом по `launcher.pyw` стартовать backend+Edge без открытия терминала.

- Стили (`legacy/styles.css`) расширены: иконки, новый контейнер для таблицы и логов, фиксированная высота панелей. Сборка `npm run build` снова прошла успешно (vite по-прежнему предупреждает только про размер чанка).






### 15.11.2025 — sticky-панель действий и единый блок таблица+лог



- `AccountSidebar.tsx`: верхний блок действий дублируется в закреплённой `sidebar-floating-actions`, поэтому «Автологин»/«Сохранить» всегда на виду; сообщения об ошибках/успехе собраны в `action-messages`, который выводится прямо под кнопками.

- Блоки профиля и cookies стали полностью icon-only: добавлен `.btn-icon`, переписаны `.path-actions`/`.btn-path`, чтобы «Открыть/Сохранить/Удалить» выстраивались в одну строку и не растягивали правую колонку.

- Для нижнего блока интерфейса таблица+журнал: сузил ресайзер, добавил внутренний паддинг `.account-log-panel-wrapper`, обновил `.account-log-panel/.account-log-body`, чтобы лог скроллился строго внутри общей карточки и больше не «тек» за пределы контейнера.

- В `legacy/styles.css` добавлен отступ в `.tabs-container`, чтобы закреплённая панель действий не перекрывала контент вкладок на небольших экранах, и фон `sidebar-floating-actions` теперь повторяет стеклянный эффект из макета.

- Дополнительная ревизия: уменьшил ширину/высоту кнопок в правой панели (`.btn-compact`, `.dual-buttons`), чтобы они соответствовали референсному макету и не перекрывали формы.
- Убрал `maxHeight` у журнала и выровнял стили `.account-log-panel*`, теперь блок логов ведёт себя статично, как во вкладке «Данные», и занимает всю доступную высоту.



**Проверки**

- `npm run build` (KeySet-MVP/frontend)

- `python launcher.pyw` — автосборка + подъем backend/UVicorn, фронт открывается без ошибок



**Что осталось**

- Жду утверждённых скриншотов правой панели и GEO-viewer, чтобы добить финальные отступы и подключить просмотрщик GEO по требованиям заказчика.


# 16.11.2025 — Массовые действия и доработка панели аккаунтов

- Вернул массовые действия из готового макета: в тулбар добавлены кнопки «Массовый запуск (5)», «Проверить авторизацию», «Экспорт списка», «История запусков» с минимальной логикой на текущих данных/эндпоинтах (`AccountModule.handleAction` + `TopBar`).
- В строке поиска теперь счётчик найдено/всего; в правой панели Basic показаны read-only поля «Статус авторизации / Последний вход / Размер профиля».
- Под таблицей добавлен компактный блок «История запусков» (email + время + статус) по текущему списку аккаунтов.
- Лог: убрана подложка-псевдоэлемент, стилизован реальный scrollbar-трек (светлый фон как во вкладке «Данные»); текст логов начинается от верхней границы.

**Проверки**
- `npm run build` (frontend) — успешно.
- `python launcher.py` — запускался, завершён по тайм-ауту ~13 с (окно Edge не закрывается в CLI), backend успел стартовать.

# 16.11.2025 — Фикс правой панели и полосы лога
- Убрал кнопку «История запусков» из тулбара, чтобы не вести в пустоту.
- Правая панель: перенёс скролл внутрь контента, закрепил нижнюю панель действий (`sidebar-floating-actions`) с дополнительным градиентом сверху, чтобы «Автологин/Сохранить» оставались видимы.
- Лог: вернул светлую полоску через стили скролл-трека и псевдоэлемент у wrapper, чтобы низ блока имитировал светлую «дорожку» как в модуле «Данные».

**Проверки**
- `npm run build` (frontend) — успешно.

# 16.11.2025 — cookiesStatus, лог аккаунтов и интеграция с backend

- KeySet-MVP/backend/routers/accounts.py уже отдаёт поле `cookies_status`; на фронте добавлен маппинг в Account.cookiesStatus через apiAccountToAccountWithCookies.
- KeySet-MVP/frontend/src/modules/accounts/index.tsx теперь использует apiAccountToAccountWithCookies при загрузке/обновлении аккаунтов, чтобы UI видел статус cookies.
- KeySet-MVP/frontend/src/modules/accounts/data/mockAccounts.ts дополнен cookiesStatus в мок-данных для сторибуков/демо.
- KeySet-MVP/frontend/src/modules/accounts/components/AccountSidebar.tsx показывает строку «Статус cookies: …» в блоке «Основное», рядом с авторизацией/последним входом/размером профиля.
- KeySet-MVP/frontend/src/modules/accounts/types.ts — cookiesStatus сделан необязательным полем (Account.cookiesStatus?), чтобы tsc не ругался на промежуточные объекты.

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — успешно (tsc -b + vite build).

# 16.11.2025 — API теста прокси для профиля

- KeySet-MVP/backend/routers/proxies.py — реализован роутер `/api/proxies/test`, который собирает строку `protocol://[user:pass@]host:port`, вызывает `services.accounts.test_proxy` и возвращает JSON с результатом (`status`, `proxy`, `response_time_ms`, `ip`, `error`).
- KeySet-MVP/backend/main.py — подключил новый роутер `proxies.router` (префикс `/api/proxies`), чтобы фронт мог пользоваться `testProxy` без Electron/IPC.
- KeySet-MVP/frontend/src/modules/accounts/api.ts — обновлён тип `ProxyTestResponse` (опциональные `response_time_ms`, `ip`, `error`), чтобы корректно парсить ответ backend.

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — успешно.

# 16.11.2025 — UI теста прокси во вкладке «Сеть»

- KeySet-MVP/frontend/src/modules/accounts/components/AccountSidebar.tsx — во вкладке «Сеть» добавлена секция проверки прокси: кнопка «Тестировать прокси» вызывает `testProxy` (через `/api/proxies/test`) для текущих `address/protocol/username/password` и отображает результат прямо в правой панели.
- При успешном ответе выводится строка вида «Прокси работает (123 мс, IP: 1.2.3.4)» зелёным цветом, при ошибке — красное сообщение с текстом из backend или собственной валидации (пустой адрес, нет порта и т.п.).
- Для UI заведены состояния `testMessage/testError/isTesting`, которые сбрасываются при переключении аккаунта; кнопка блокируется, если адрес пустой или идёт активная проверка.

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — успешно (tsc + Vite).

# 16.11.2025 — Обновление модуля объявлений: новая левая панель и Яндекс превью

- KeySet-MVP/frontend/src/modules/announcements/App.tsx — заменена левая панель на версию из готового модуля ads-creator-standalone (4).html:
  - Добавлены поля настроек URL: домен, UTM-шаблон, ID группы
  - Прибавки к заголовку №2 (textarea)
  - Тексты объявлений (textarea)
  - Ключевые фразы (textarea) с подсчётом количества фраз
- В центральный блок интегрировано превью Яндекса из yandex_direct_layout.html:
  - Шапка поиска с логотипом Яндекса
  - Блок объявления с заголовками, отображаемой ссылкой и текстом
  - Сохранён оригинальный дизайн и стили Яндекс.Директа
- Обновлена функция handleGenerateAds для работы с новым интерфейсом ввода фраз через textarea
- KeySet-MVP/frontend/src/modules/announcements/App.css — добавлены стили для новых элементов:
  - .ads-input, .ads-textarea, .ads-hint для левой панели
  - Полный набор стилей для Яндекс превью (.yandex-preview-page, .yandex-logo, .yandex-ad-title и т.д.)
  - Кастомные scrollbar стили для превью


  - .yandex-ad-body (контакты и тексты)
  - .yandex-dynamic-flag, .yandex-toggle-switch, .yandex-toggle-track, .yandex-toggle-knob
  - Отступы для всех строк (yandex-ad-row-title/text/clarify/contacts/sitelinks)

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — успешно (2484 модуля)
- Git commit + push выполнены

Теперь превью полностью соответствует скриншоту Яндекс.Директа со всеми функциями.

- backend/routers/proxies.py: кроме POST /api/proxies/test добавлены GET /api/proxies (возвращает список ProxyManager.list с geo/last_check/last_ip) и POST /api/proxies/assign (через services.accounts.set_account_proxy привязывает proxy_id/strategy к аккаунту).

- frontend/src/modules/accounts/api.ts: добавлены типы ProxyItem/ProxyListResponse/ProxyAssignResponse и функции fetchProxies()/assignProxyToAccount(), которые бьют в новые эндпоинты; UI вкладки 'Менеджер прокси' пока не трогал, чтобы не ломать верстку до отдельной итерации.

# 16.11.2025 — Обновление 'Мои потребности' и процесса

- В 'бд/инструкции/Архитектура/Задачи/Новое/Мои потребности.md' добавлен раздел 'Процесс / поведение агента': зафиксированы требования перечитывать 'ПАМЯТКА_Codex.md' перед работой, вести этот файл актуальным, обновлять отчёт 'ЧТО УЖЕ СДЕЛАЛ.md' после логических блоков и строго работать в UTF-8.
- Отдельно записана цель по аккаунтам: возможность 'менять аккаунты как перчатки' — быстро подключать/отключать аккаунты с их прокси/профилем/cookies/fingerprint без палевных паттернов для Яндекса.

**Проверки**
- Файл 'Мои потребности.md' перечитан и пересохранён через Get-Content/Set-Content -Encoding UTF8, чтобы гарантировать корректную кодировку.


# 16.11.2025 — Живой список ProxyManager во вкладке 'Менеджер прокси'

- KeySet-MVP/frontend/src/modules/accounts/components/AccountSidebar.tsx: во вкладке 'Менеджер прокси' добавлен React-блок ProxyManagerSection, который подгружает список прокси через fetchProxies(), показывает их в таблице (IP:Port, GEO, последний IP, статус) и позволяет выбирать строку.
- Из ProxyManagerSection можно протестировать выбранный прокси (testProxy через /api/proxies/test) и применить его к текущему аккаунту (assignProxyToAccount через /api/proxies/assign); после успешного применения вызывается reload аккаунтов, чтобы таблица и правая панель увидели новый proxy.
- Макет старого менеджера прокси (парсинг, тест списка, ротация) сохранён как отдельные секции, поверх него добавлен живой список в том же стиле (.proxy-manager-container/.proxy-section/.proxy-table).
- KeySet-MVP/frontend/src/modules/accounts/index.tsx: в AccountSidebar передаётся onReloadAccounts={loadAccounts}, чтобы после привязки прокси общий список аккаунтов обновлялся с backend.

**Проверки**
- npm run build (KeySet-MVP/frontend) — успешно (tsc -b + vite build).


# 16.11.2025 — Базовая консистентность аккаунтов (прокси/cookies/профиль)

- KeySet-MVP/frontend/src/modules/accounts/types.ts: в модель Account добавлены поля consistencyLabel/consistencyWarning, чтобы UI мог показывать простой итог по связке профиль/прокси/cookies.
- KeySet-MVP/frontend/src/modules/accounts/mapper.ts: в apiAccountToAccountWithCookies() на основе profilePath/proxy и cookies_status вычисляется консистентность: 'Нет профиля', 'Нет прокси', 'Нет cookies', 'Просроченные cookies', 'Старые cookies' или 'Ок', плюс флаг предупреждения (consistencyWarning).
- KeySet-MVP/frontend/src/modules/accounts/components/AccountsTable.tsx: в таблицу аккаунтов добавлена колонка 'Консистентность' с бейджами (зелёный/жёлтый/серый), чтобы сразу видеть проблемные аккаунты (без прокси/куков/профиля).
- KeySet-MVP/frontend/src/modules/accounts/legacy/styles.css: добавлены стили .consistency-badge/* в том же стиле, что и статусные бейджи, без ломки существующей верстки.

**Проверки**
- npm run build (KeySet-MVP/frontend) — успешно (tsc -b + vite build).

## 17.11.2025 — ProxyManager и связывание аккаунтов

- backend/routers/accounts.py — API теперь возвращает `proxy_id` и `proxy_strategy`, чтобы фронт видел привязку ProxyManager.
- frontend/src/modules/accounts/{types.ts, api.ts, mapper.ts} — добавлены поля `proxyId`/`proxyStrategy`, маппинг в payload'ы create/update, нормализация стратегии.
- frontend/src/modules/accounts/components/AccountSidebar.tsx — вкладка «Менеджер прокси» выбирает строку по текущему `proxyId`, позволяет задавать стратегию (fixed/rotate), очищает `proxyId` при ручном вводе прокси.

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — ❌ `src/modules/announcements/App.tsx(342,13): Expected corresponding JSX closing tag for 'div'` (ошибка была в репозитории до правки, build останавливается на этом же месте).
- `python launcher.py` (KeySet-MVP, timeout 30 c) — ⚠️ backend поднимается, но встроенный `npm run build` также падает по той же ошибке App.tsx; launcher выводит: `Command '['npm.cmd', 'run', 'build']' returned non-zero exit status 2.`
## 17.11.2025 — Чистка App.tsx и сборка фронта

- frontend/src/modules/announcements/App.tsx — убрал дублирующийся `</button></div>` и лишний комментарий в боковой панели, чтобы JSX корректно закрывался.
- frontend/src/modules/accounts/data/mockAccounts.ts — добавлены `proxyId`/`proxyStrategy` для мок-данных, чтобы соответствовать обновлённому типу Account.

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — ✅ успешно, Vite собрал SPA (2485 модулей).
- `python launcher.py` (KeySet-MVP, timeout 30 c) — ✅ backend поднялся, встроенный `npm run build` отработал без ошибок (в логах только стандартное предупреждение о размере chunk).
## 17.11.2025 — Прокси-менеджер в React

- backend/routers/proxies.py — добавлены Create/Update/Delete для ProxyManager: API теперь умеет создавать новые прокси, редактировать параметры (тип, geo, sticky, max_concurrent, notes) и удалять записи. Helper `_proxy_to_item` избавляет от дублирования.
- frontend/src/modules/accounts/api.ts — расширен API-клиент (createProxy/updateProxy/deleteProxy + тип ProxyUpsertPayload).
- frontend/src/modules/accounts/components/AccountSidebar.tsx — вкладка «Менеджер прокси»: таблица с реальными статусами, действия (редактировать/включить/удалить), форма добавления/редактирования с контролем sticky/maxConcurrent, выбор стратегии и кнопки теста/применения работают поверх новых API. Старые статические блоки «Парсинг/Tестирование/Ротация» убраны как заглушки.

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — ✅
- `python launcher.py` (KeySet-MVP, timeout 30 c) — ✅ build внутри launcher проходит, UI открывается.

## 18.11.2025 — Журнал аккаунтов и логика прокси

- frontend/src/modules/accounts/components/AccountSidebar.tsx:
  - Вкладка «Сеть»: тест прокси теперь дополнительно пишет результат в общий журнал аккаунта (успех/ошибка/исключение с деталями — хост, порт, протокол, задержка и IP), чтобы не терять информацию в локальных подсказках.
  - Вкладка «Менеджер прокси»: все ключевые действия (массовый тест, тест выбранного прокси, очистка списка, парсинг, превью) теперь передают сообщения в `onLog`, которые отображаются в нижнем журнале (AccountLogPanel), а не только во внутренних `bulkMessage`/`testMessage`.
- Повторно собран фронтенд: журнал аккаунтов теперь показывает историю работы с прокси и сетью в одном месте (автологин, запуск, тесты прокси, парсинг, очистка).

**Проверки**
- `npm run build` (KeySet-MVP/frontend) — ✅ (tsc -b + vite build, только стандартное предупреждение Vite о размере чанков).
- `python launcher.py` (KeySet-MVP, timeout 30–40 c) — ✅ backend поднимается, встроенный `npm run build` проходит; UI «Аккаунты»/«Данные» открывается, журнал аккаунтов наполняется событиями по работе с прокси.



18.11.2025 — Codex: подключены бесплатные источники прокси (proxyscrape, proxifly, proxy-list.download) в services/proxy_parsers.py, /api/proxies/parse теперь умеет парсить их через новые значения sources.
